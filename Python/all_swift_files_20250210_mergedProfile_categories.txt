// Content from: ../Equipment Booking/CartItem.swift

//
//  CartItem.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import Foundation

struct CartItem: Identifiable {
    let id = UUID()
    let tool: Tool
    var quantity: Int
}


// Content from: ../Equipment Booking/CartManager.swift

//
//  Untitled.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//
import SwiftUI

class CartManager: ObservableObject {
    @Published var cartItems: [CartItem] = []
    
    func addToCart(_ tool: Tool, quantity: Int) {
        if let index = cartItems.firstIndex(where: { $0.tool.id == tool.id }) {
            // Om verktyget redan finns i kundvagnen, Ã¶ka kvantiteten
            cartItems[index].quantity += quantity
        } else {
            // LÃ¤gg till nytt verktyg i kundvagnen
            cartItems.append(CartItem(tool: tool, quantity: quantity))
        }
    }
    
    func removeFromCart(at offsets: IndexSet) {
        cartItems.remove(atOffsets: offsets)
    }
    
    func updateQuantity(for tool: Tool, quantity: Int) {
        if let index = cartItems.firstIndex(where: { $0.tool.id == tool.id }) {
            cartItems[index].quantity = quantity
            if cartItems[index].quantity <= 0 {
                        cartItems.remove(at: index)
                    }
        }
    }
}



// Content from: ../Equipment Booking/CartView.swift

//
//  CartView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct CartView: View {
    @EnvironmentObject var cartManager: CartManager

    var body: some View {
        List {
            ForEach(cartManager.cartItems) { cartItem in
                HStack {
                    VStack(alignment: .leading) {
                        Text(cartItem.tool.name)
                            .font(.headline)
                        Text("Price: \(cartItem.tool.price) SEK")
                            .foregroundColor(Color.gray)
                    }
                    Spacer()
                    HStack {
                        Button(action: {
                            cartManager.updateQuantity(for: cartItem.tool, quantity: cartItem.quantity - 1)
                        }) {
                            Image(systemName: "minus.circle")
                        }
                        .buttonStyle(PlainButtonStyle())
                        .padding(.horizontal, 8)
                        
                        Text("\(cartItem.quantity)")
                            .padding(.horizontal)
                        Button(action: {
                            cartManager.updateQuantity(for: cartItem.tool, quantity: cartItem.quantity + 1)
                        }) {
                            Image(systemName: "plus.circle")
                        }
                        .buttonStyle(PlainButtonStyle())
                        .padding(.horizontal, 8)
                    }
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    
                }
            }
            .onDelete { offsets in
                cartManager.removeFromCart(at: offsets)
            }
        }
        .navigationTitle("Cart")
    }
}


#Preview {
    Equipment_Details(tool: exampleTool)
        .environmentObject(CartManager()) 
}





// Content from: ../Equipment Booking/CategoriesView.swift

import SwiftUI

struct CategoriesView: View {
    @State var columns = [
        GridItem(.flexible(), spacing: 16),
        GridItem(.flexible(), spacing: 16)
    ]
    @State var categoryInput = ""
    @State var categories: [Category] = []
    @State var descriptionInput = ""
    
    var body: some View {
        VStack {
           
            HStack {
                VStack {
                    TextField("Category", text: $categoryInput)
                        .border(Color.black)
                        .padding()
                        .foregroundColor(Color.black)
                        .cornerRadius(10)
                    
                    TextField("Description", text: $descriptionInput)
                        .border(Color.black)
                        .padding()
                        .foregroundColor(Color.black)
                        .cornerRadius(10)
                }
                Button(action: {
                    addCategory()
                }) {
                    Text("Add")
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(10)
                }
            }
            ScrollView {
                LazyVGrid(columns: columns) {
                    ForEach(categories) { category in
                        CategoryBoxView(category: category)
                            .frame(height: 200)
                    }
                }
                .padding()
            }
        }
    }
    
    func addCategory() {
        guard !categoryInput.isEmpty, !descriptionInput.isEmpty else { return }
        
        let newCategory = Category(title: categoryInput, description: descriptionInput)
        categories.append(newCategory)
        
        categoryInput = ""
        descriptionInput = ""
    }
}

#Preview {
    CategoriesView()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/CategoryBoxView.swift

//
//  CategoryBoxView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-16.
//

import SwiftUI

struct CategoryBoxView: View {
    @State var category: Category
    var body: some View {
        
            VStack {
                Text(category.title)
                    .font(.title)
                    .multilineTextAlignment(.center)
                Spacer()
                Text(category.description)
                    .font(.subheadline)
                    .foregroundColor(Color.gray)
                    .multilineTextAlignment(.center)
                Spacer()
            }
            .padding()
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: 200)
            .border(Color.black)
            .cornerRadius(10)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(Color.black, lineWidth: 1)
            )
    }
}

#Preview {
    CategoryBoxView(category: Category(title: "Books", description: "Find your favorite books"))
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/CategoryClass.swift

//
//  CategoryClass.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-16.
//

import Foundation

class Category: Identifiable {
    var id = UUID()
    let title: String
    let description: String
    
    init(title: String, description: String) {
        self.id = UUID()
        self.title = title
        self.description = description
    }
}


// Content from: ../Equipment Booking/CategoryData.swift

//
//  CategoryData.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-16.
//

import Foundation

let categories = [
        Category(title: "Books", description: "Find your favorite books"),
        Category(title: "Laptops", description: "Reserve high-end laptops"),
        Category(title: "Cameras", description: "Capture moments with cameras")
    ]


// Content from: ../Equipment Booking/CategoryView.swift

//
//  ConstructionView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct CategoryView: View {
    var category: String
    var title: String
    @State private var tools = toolData
    @State private var searchText = ""
    @State private var isShowingResults = false
    
    var filteredTools: [Tool] {
        tools.filter { tool in
            (tool.category == category) &&
            (searchText.isEmpty || tool.name.localizedCaseInsensitiveContains(searchText))
        }
    }
    
    var body: some View {
        VStack {
            HStack {
                TextField("Search in \(title)", text: $searchText)
                    .padding(.leading)
                    .frame(maxWidth: .infinity, maxHeight: 50)
                    .background(Color(.systemGray6))
                    .cornerRadius(8)
                    .padding([.top, .leading])
                
                Button(action: {isShowingResults.toggle()}) {
                    Image(systemName: "magnifyingglass")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: 40, maxHeight: 50)
                        .background(searchText.isEmpty ? Color.gray : Color.blue)
                        .cornerRadius(8)
                        .padding([.top, .trailing])
                }
                .disabled(searchText.isEmpty)
            }// Hstack
            
            List(isShowingResults ? filteredTools : tools.filter{$0.category == category}) { tool in
                NavigationLink(destination: Equipment_Details(tool: tool)) {
                    HStack {
                        VStack(alignment: .leading) {
                            Text(tool.name)
                                .font(.headline)
                            Text(tool.description)
                                .font(.subheadline)
                                .foregroundColor(Color.gray)
                            Text("Price Per Day: \(tool.price)$")
                                .foregroundColor(Color.red)
                                .font(.caption)
                        }
                        Spacer()
                        if tool.isAvailable {
                            Text("Available")
                                .font(.caption)
                                .foregroundColor(Color.green)
                        } else {
                            Text("Unavailable")
                                .font(.caption)
                                .foregroundColor(Color.red)
                        }
                    } //Hstack
                } //Navigationlink
            } //List
            .onChange(of: searchText) { newValue in
                if newValue.isEmpty {
                    isShowingResults = false
                }
            }
            Spacer()
        } //Vstack
        .navigationTitle("\(title) Tools")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .principal) {
                Text("\(title) Tools")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)
            }
        }
    }
}

#Preview {
    CategoryView(category: "Construction", title: "Construction")
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/ConstructionView.swift

//
//  ConstructionView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct ConstructionView: View {
    var body: some View {
        CategoryView(category: "Construction", title: "Construction")
    }
}

#Preview {
    ConstructionView()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/ContentView.swift

//
//  ContentView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-01.
//

import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundStyle(.tint)
            Text("Hello")
        }
      
    }
}

#Preview {
    ContentView()
        .environmentObject(CartManager())
}





// Content from: ../Equipment Booking/ElectricalView.swift

//
//  ElectricalView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct ElectricalView: View {
    var body: some View {
        CategoryView(category: "Electrical", title: "Electrical")
    }
}

#Preview {
    ElectricalView()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/Equipment Details.swift

import SwiftUI

struct Equipment_Details: View {
    var tool: Tool
    @EnvironmentObject var cartManager: CartManager
    @State private var selectPickupDate: Date = Date()
    @State private var selectReturnDate: Date? = nil
    @State private var isShowingDatePicker = false
    @State private var isPickingDate = true
    @State private var quantity: Int = 1
    @State private var showConfirmation = false

    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter
    }
    
    var isAddToCartEnabled: Bool {
            if var returnDate = selectReturnDate {
                return selectPickupDate < returnDate
            }
            return false
        }

    func handleDateSelection(_ date: Date) {
        if isPickingDate {
            selectPickupDate = date
            if var returnDate = selectReturnDate, returnDate < selectPickupDate {
                selectReturnDate = selectPickupDate
            }
        } else {
            selectReturnDate = date
            if selectPickupDate > date {
                selectPickupDate = date
            }
        }
        isShowingDatePicker = false
    }

    var body: some View {
        ZStack {
            VStack {
                Text(tool.name)
                    .font(.largeTitle)
                    .padding()

                Image(systemName: "hammer.fill")
                    .frame(width: 400.0, height: 300.0)
                    .imageScale(.large)
                    .foregroundStyle(.tint)
                    .background(Color.black)

                HStack {
                    VStack(alignment: .leading) {
                        Text("Description")
                            .font(.title)
                        Text(tool.description)
                            .padding(.trailing)
                            .font(.subheadline)
                            .foregroundColor(Color.gray)
                        Text("Price per day: \(tool.price) SEK")
                            .font(.headline)
                            .foregroundColor(Color.red)
                            .padding([.top, .bottom, .trailing])
                    }
                    .padding(.leading)

                    Spacer()
                    VStack {
                        HStack {
                            Button(action: {
                                if quantity > 1 {
                                    quantity -= 1
                                }
                            }) {
                                Image(systemName: "minus")
                                    .frame(width: 30, height: 30)
                                    .foregroundColor(.white)
                                    .background(Color.blue)
                                    .clipShape(Circle())
                            }

                            Text("\(quantity)")
                                .font(.title3)
                                .padding(10)

                            Button(action: {
                                quantity += 1
                            }) {
                                Image(systemName: "plus")
                                    .frame(width: 30, height: 30)
                                    .foregroundColor(.white)
                                    .background(Color.blue)
                                    .clipShape(Circle())
                            }
                        }
                    }.padding(.trailing)
                }

                VStack {
                    HStack {
                        Button("Pick Pickup Date") {
                            isPickingDate = true
                            isShowingDatePicker.toggle()
                        }
                        .padding(10)
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)

                        Spacer()
                        Text(dateFormatter.string(from: selectPickupDate))
                            .padding(.horizontal)
                            .font(.subheadline)
                            .foregroundColor(.black)
                    }

                    HStack {
                        Button("Pick Return Date") {
                            isPickingDate = false
                            isShowingDatePicker.toggle()
                        }
                        .padding(10)
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)

                        Spacer()
                        if var returnDate = selectReturnDate {
                            Text(dateFormatter.string(from: returnDate))
                                .padding(.horizontal)
                                .font(.subheadline)
                                .foregroundColor(.black)
                        } else {
                            Text("Select Date")
                                .italic()
                                .foregroundColor(.gray)
                                .padding(.trailing)
                        }
                    }
                }
                .padding(.leading)

                Spacer()

                Button(action: {
                    if var returnDate = selectReturnDate {
                        cartManager.addToCart(tool, quantity: quantity)
                        showConfirmation = true
                    }
                }) {
                    Text("Add to Cart")
                        .frame(width: 200.0, height: 50.0)
                        .background(isAddToCartEnabled ? Color.green : Color.gray.opacity(0.5))
                        .foregroundColor(.white)
                        .cornerRadius(8)
                }
                .disabled(!isAddToCartEnabled)
                .padding()
                .alert(isPresented: $showConfirmation) {
                    Alert(
                        title: Text("Added to Cart"),
                        message: Text("\(quantity) x \(tool.name) added to your cart."),
                        dismissButton: .default(Text("OK"))
                    )
                }
            }
            .padding()

            if isShowingDatePicker {
                VStack {
                    DatePicker(
                        "Select Date",
                        selection: isPickingDate ? $selectPickupDate : Binding(
                            get: {selectReturnDate ?? Date()},
                            set: {selectReturnDate = $0}
                        ),
                        in: Date.now...,
                        displayedComponents: .date
                    )
                    .datePickerStyle(GraphicalDatePickerStyle())
                    .padding()
                    .background(Color.white)
                    .cornerRadius(10)
                    .shadow(radius: 10)

                    Button("Done") {
                        handleDateSelection(isPickingDate ? selectPickupDate : (selectReturnDate ?? Date()))
                    }
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(10)
                }
                .padding(.horizontal, 20.0)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.black.opacity(0.5))
            }
        }
    }
}
let exampleTool = Tool(
    name: "Hammer",
    description: "A sturdy hammer for construction work.",
    price: 15,
    isAvailable: true,
    category: "Construction"
)
#Preview {
    Equipment_Details(tool: exampleTool)
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/Equipment_BookingApp.swift

//
//  Equipment_BookingApp.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-11-24.
//

import SwiftUI
import FirebaseCore

@main
struct Equipment_BookingApp: App {
    @StateObject private var cartManager = CartManager()
    
    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
    
    var body: some Scene {
        WindowGroup {
            if #available(iOS 18.0, *) {
                RootView() // Landing page on app start up
//                TabsView()
                //            ContentView()
                    .environmentObject(cartManager)
            } else {
                // Fallback on earlier versions
            }
        }
    }
}
 
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        FirebaseApp.configure()  // call config
 
        if FirebaseApp.app() == nil
        {
            print("Firebase initialisation failed!")
        } else {
            if let apiKey = FirebaseApp.app()?.options.apiKey {
                print("Firebase API Key Used: \(apiKey)")
            }
        }
        return true
 
    }
}






// Content from: ../Equipment Booking/EquipmentList.swift

//
//  EquipmentList.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-11-30.
//


// We need to use FB database

import Foundation

let toolData: [Tool] = [
    Tool(name: "Drill Machine",
         description: "High-power drill machine",
         price: 10,
         isAvailable: true,
         category: "Industrial"),
    Tool(name: "Hammer",
         description: "Heavy-duty hammer",
         price: 4,
         isAvailable: true,
         category: "Electrical"),
    Tool(name: "Screwdriver Set",
         description: "Set of precision screwdrivers",
         price: 6,
         isAvailable: false,
         category: "Construction")
]


// Content from: ../Equipment Booking/Equipments.swift

//
//  Equipments.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-11-30.
//

import Foundation
struct Tool: Identifiable{
    var id = UUID()
    var name: String
    var description: String
    var price: Int
    var isAvailable: Bool
    var category: String
}


// Content from: ../Equipment Booking/IndustrialView.swift

//
//  IndustrialView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct IndustrialView: View {
    var body: some View {
        CategoryView(category: "Industrial", title: "Industrial")
    }
}

#Preview {
    IndustrialView()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/ProfileMenuView.swift

//
//  ProfileMenuView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/5/24.
//

import SwiftUI

struct ProfileMenuView: View {
    @Binding var isMenuOpen: Bool // Track the menu visibility from the parent
    
    var body: some View {
        VStack {
            // Spacer to push everything down
            Spacer()
                .frame(height: 30) //
            
            // Back Button and Profile Image
            HStack {
                Button(action: {
                    withAnimation {
                        isMenuOpen = false // Close the menu
                    }
                }) {
                    Image(systemName: "chevron.left")
                        .font(.title)
                        .foregroundColor(.blue)
                        .padding(.leading, 20)
                }
                Spacer()
                
                // Profile Image (Centered)
                Image(systemName: "person.crop.circle")
                    .resizable()
                    .frame(width: 100, height: 100)
                    .foregroundColor(.gray)
                    // .padding(.top, 5) // Add extra padding to space it out more
                
                Spacer()
                
                // Shopping Cart Icon
                Button(action: {
                    // Action for shopping cart icon )
                    print("Shopping Cart tapped")
                }) {
                    Image(systemName: "cart")
                        .font(.title)
                        .foregroundColor(.blue)
                        .padding(.trailing, 20) // Align with the chevron button
                }
                        
                
            }
            
            
            //.padding(.bottom, 30)
            
            
            // Menu List with Dividers and Raised Effect
            VStack(spacing: 5) { // Use 0 spacing to create clean divider placement
                MenuItem(icon: "person", text: "Account", action: {})
                // Divider()
                MenuItem(icon: "bell", text: "Notifications", action: {})
                //Divider()
                MenuItem(icon: "gearshape", text: "Settings", action: {})
                //Divider()
                MenuItem(icon: "questionmark.circle", text: "Support", action: {})
            }
            .padding(.top, 30)
            .padding(.horizontal, 10)
            
            
            
            // Sign Out Button
            Button(action: {
                withAnimation {
                    isMenuOpen = false // Close the menu
                }
                print("Signed out and navigated back to home.")
            }) {
                HStack {
                    Image(systemName: "arrow.backward.square")
                        .font(.headline)
                    Text("Sign Out")
                        .fontWeight(.bold)
                }
                .font(.headline)
                .foregroundColor(.white)
                .frame(height: 55)
                .frame(maxWidth: .infinity)
                .background(Color.red)
                .cornerRadius(10)
                .padding(.horizontal)
            }
            Spacer()
            
        }
    }
}

// Reusable Menu Item View with Action Support
struct MenuItem: View {
    let icon: String
    let text: String
    let action: () -> Void // Closure for button action
    
    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.headline)
                    .foregroundColor(.blue)
                Text(text)
                    .font(.headline)
                    .foregroundColor(.black)
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(Color.white)
                    .shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2) // Subtle shadow for raised effect
                            ) // Subtle shadow for raised effect
            
        }
        .padding(.horizontal, 10) // Add horizontal padding to ensure items don't touch the screen edge
    }
}

#Preview {
    // Creating a Binding to pass into the ProfileMenuView
    ProfileMenuView(isMenuOpen: .constant(true)) // Use .constant(true) for the preview
}


// Content from: ../Equipment Booking/Search.swift

//
//  Search.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-01.
//

import SwiftUI
import Firebase
import FirebaseFirestore

struct Search: View {
    @State private var tools = toolData
    @State private var searchText = ""
    @State private var isShowingResults = false
    
    var filteredTools: [Tool] {
        if searchText.isEmpty{
            return tools
        } else {
            return tools.filter{
                $0.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        if #available(iOS 16.0, *) {
            NavigationStack{
                VStack{
                    HStack {
                        TextField("Search...", text: $searchText)
                            .frame(maxWidth: .infinity, maxHeight: 40)
                            .padding(10)
                            .background(Color(.systemGray6))
                            .cornerRadius(8)
                            .padding([.top, .leading, .trailing])
                        
                        Button(action: {isShowingResults = true}) {
                            Image(systemName: "magnifyingglass")
                                .font(.headline)
                                .foregroundColor(Color.white)
                                .frame(maxWidth: 40, maxHeight: 60)
                                .background(searchText.isEmpty ? Color.gray : Color.blue)
                                .cornerRadius(8)
                                .padding([.top, .trailing])
                        }
                    }
                    
                    
               
                    NavigationLink(destination: ConstructionView()) {
                        Text("Construction")
                            .font(.title2)
                            .multilineTextAlignment(.center)
                            .frame(maxWidth: .infinity, minHeight: 100)
                            .background(Color.orange)
                            .cornerRadius(8)
                            .padding([.top, .leading, .trailing])
                    }
                    
                    NavigationLink(destination: IndustrialView()) {
                        Text("Industrial")
                            .font(.title2)
                            .multilineTextAlignment(.center)
                            .frame(maxWidth: .infinity, minHeight: 100)
                            .background(Color.gray)
                            .cornerRadius(8)
                            .padding([.top, .leading, .trailing])
                    }
                        
                    NavigationLink(destination: ElectricalView()) {
                        Text("Electrical")
                            .font(.title2)
                            .multilineTextAlignment(.center)
                            .frame(maxWidth: .infinity, minHeight: 100)
                            .background(Color.yellow)
                            .cornerRadius(8)
                            .padding([.top, .leading, .trailing])
                    }
                    Spacer()
                } //Vstack
                .sheet(isPresented: $isShowingResults) {
                    SearchResultsView(tools: filteredTools)
                }
            } //Navigation
        }
    }
}

#Preview {
    Search()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/SearchResultsView.swift

//
//  SearchResultsView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2025-01-05.
//

import SwiftUI

struct SearchResultsView: View {
    
    var tools: [Tool]
    
    var body: some View {
        if #available(iOS 16.0, *) {
            NavigationStack {
                List(tools) { tool in
                    VStack(alignment: .leading) {
                        Text(tool.name)
                            .font(.headline)
                        Text(tool.description)
                            .font(.subheadline)
                            .foregroundColor(Color.gray)
                        Text("Price per day: \(tool.price)$")
                            .foregroundColor(Color.red)
                            .font(.caption)
                        if tool.isAvailable {
                            Text("Available")
                                .font(.caption)
                                .foregroundColor(Color.green)
                        } else {
                            Text("Unavailable")
                                .font(.caption)
                                .foregroundColor(Color.red)
                        }
                    }
                }
                .navigationTitle("Search Results")
                .navigationBarTitleDisplayMode(.inline)
            }
        }
    }
}

#Preview {
    Search()
        .environmentObject(CartManager())
}


// Content from: ../Equipment Booking/TabsView.swift

//
//  TabsView.swift
//  Equipment Booking
//
//  Created by YYYYYYYY on 2024-12-16.
//

import SwiftUI


@available(iOS 18.0, *)

struct TabsView: View {
    
    var body: some View {
        TabView {
            Tab("Search", systemImage: "magnifyingglass") {
                Search()
            }
            Tab("Cart", systemImage: "cart") {
                CartView()
            }
            Tab("Status", systemImage: "person.crop.circle") {
                UserProfileView()
                // UserAuthenticationView()
            
                
            }
        }
    }
}

#Preview {
    if #available(iOS 18.0, *) {
        TabsView()
            .environmentObject(CartManager())
    }
}


// Content from: ../Equipment Booking/Core/RootView.swift

//
//  RootView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/9/24.
//

import SwiftUI


struct RootView: View {
    @StateObject private var authViewModel = AuthenticationViewModel()

    var body: some View {
        ZStack {
            if authViewModel.isAuthenticated {
                NavigationStack {
                    EquipmentListingView()
                }
            } else {
                NavigationStack {
                    UserAuthenticationView(showSignInView: .constant(false))
                        .environmentObject(authViewModel)
                }
            }
        }
        .onAppear {
            // Check authentication status on app launch
            checkAuthenticationStatus()
        }
        .environmentObject(authViewModel) // Provide auth state globally
    }

    private func checkAuthenticationStatus() {
        do {
            let _ = try AuthenticationManager.shared.getAuthenticatedUser()
            authViewModel.isAuthenticated = true
        } catch {
            authViewModel.isAuthenticated = false
        }
    }
}


struct RootView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            RootView()
        }
    }
}









// Content from: ../Equipment Booking/Core/Authentication/AuthenticationViewModel.swift

//
//  AuthenticationViewModel.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/29/24.
//

import Foundation
import FirebaseAuth

@MainActor
final class AuthenticationViewModel: ObservableObject {
    @Published var email: String = "" // Add this property
    @Published var password: String = "" // Include this if needed for sign-in
    @Published var authUser: AuthDataResultModel? = nil // Track authenticated user
    @Published var isAuthenticated: Bool = false  // Track authentication state
    
    
    func checkAuthenticationStatus() {
        if let user = Auth.auth().currentUser {
            self.authUser = AuthDataResultModel(user: user)
            self.isAuthenticated = true // âœ… Automatically set authentication status
        } else {
            self.isAuthenticated = false
        }
    }
    
    
    func signInGoogle() async throws {
        let helper = SignInGoogleHelper()
        let tokens = try await helper.signIn()
        let authDataResult = try await AuthenticationManager.shared.signInWithGoogle(tokens: tokens)
        let user = DBUser(auth: authDataResult)
        try await UserManager.shared.createNewUser(user: user)
    }
    
//    func signInAnonymous() async throws {
//        let authDataResult = try await AuthenticationManager.shared.signInAnonymous()
//        let user = DBUser(auth: authDataResult)
//        try await UserManager.shared.createNewUser(user: user)
//    }
    
    
    // Sign in with email and password / checking if user is already signed in
    func signIn() async throws {
        let normalizedEmail = email.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedPassword = password.trimmingCharacters(in: .whitespacesAndNewlines)

//        // Debugging print statements
//        print("Attempting Firebase sign-in with:")
//        print("Email: \(normalizedEmail)")
//        print("Password Length: \(trimmedPassword.count)")

        guard !normalizedEmail.isEmpty, !trimmedPassword.isEmpty else {
            throw NSError(domain: "InvalidInput", code: 422, userInfo: [NSLocalizedDescriptionKey: "Email and password cannot be empty."])
        }

        do {
            let authDataResult = try await Auth.auth().signIn(withEmail: normalizedEmail, password: trimmedPassword)
            self.authUser = AuthDataResultModel(user: authDataResult.user)
            self.isAuthenticated = true
        } catch let error as NSError {
//            print("Firebase Error Code: \(error.code)")
//            print("Firebase Error Domain: \(error.domain)")
//            print("Firebase Error Message: \(error.localizedDescription)")

            // First, attempt to get the AuthErrorCode mapping
            if let authErrorCode = AuthErrorCode(_bridgedNSError: error) {
                switch authErrorCode {
                case .userNotFound:
                    throw NSError(domain: "EmailNotRegistered", code: 404, userInfo: [NSLocalizedDescriptionKey: "Email not registered. Please sign up or try again."])
                case .invalidEmail:
                    throw NSError(domain: "InvalidEmail", code: 400, userInfo: [NSLocalizedDescriptionKey: "Invalid email format. Please check and try again."])
                case .wrongPassword:
                    throw NSError(domain: "InvalidPassword", code: 401, userInfo: [NSLocalizedDescriptionKey: "Incorrect password. Try again."])
                default:
                    throw NSError(domain: "UnknownError", code: 500, userInfo: [NSLocalizedDescriptionKey: "An unexpected error occurred."])
                }
            } else {
                // If `AuthErrorCode(_bridgedNSError: error)` fails, manually check the error code
                switch error.code {
                case 17011: // userNotFound
                    throw NSError(domain: "EmailNotRegistered", code: 404, userInfo: [NSLocalizedDescriptionKey: "Email not registered. Please sign up or try again."])
                case 17009: // wrongPassword
                    throw NSError(domain: "InvalidPassword", code: 401, userInfo: [NSLocalizedDescriptionKey: "Incorrect password. Try again."])
                case 17008: // invalidEmail
                    throw NSError(domain: "InvalidEmail", code: 400, userInfo: [NSLocalizedDescriptionKey: "Invalid email format. Please check and try again."])
                case 17005: // userDisabled
                    throw NSError(domain: "UserDisabled", code: 403, userInfo: [NSLocalizedDescriptionKey: "This account has been disabled."])
                default:
                    print("ðŸ”¥ Failed to map error. Returning generic error.")
                    throw NSError(domain: "UnknownError", code: 500, userInfo: [NSLocalizedDescriptionKey: "An unexpected error occurred."])
                }
            }
        }
    }
    
    
    // Sign up new user an login immediately
    
    func signUpAndLogin(email: String, password: String) async throws {
        let normalizedEmail = email.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedPassword = password.trimmingCharacters(in: .whitespacesAndNewlines)
        
        do {
            // Sign up the user
            let authDataResult = try await AuthenticationManager.shared.createUser(email: normalizedEmail, password: trimmedPassword)
            
            // Save authenticated user (should immediately sign them in)
            self.authUser = authDataResult
            
            // Set additional profile information
            let user = DBUser(auth: authDataResult)
            try await UserManager.shared.createNewUser(user: user)
            
            // âœ… Mark user as authenticated
            self.isAuthenticated = true
        } catch {
            // Handle errors during sign-up
            print("Sign-up error: \(error.localizedDescription)")
            throw error
        }
    }
    
}



// Content from: ../Equipment Booking/Core/Authentication/UserAuthenticationView.swift

//
//  UserAuthenticationView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/8/24.
//

import SwiftUI
import GoogleSignIn
import GoogleSignInSwift
import AuthenticationServices // for Apple Sign-In


struct UserAuthenticationView: View {
    @StateObject private var viewModel = AuthenticationViewModel()
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var emailErrorMessage: String?
    @Binding var showSignInView: Bool
    @State private var showPassword: Bool = false
    @State private var showForgotPassword: Bool = false
    @State private var errorMessage: String? = nil
    @State private var navigateToSignUp: Bool = false
    @State private var showInlineSignUp: Bool = false
    @State private var NavigateToTabsView: Bool = false
    
    @FocusState private var focusedField: Field?
    
    enum Field {
        case email, password
    }
    
    private var isSignInButtonEnabled: Bool {
        return emailErrorMessage == nil && !viewModel.password.isEmpty
    }
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Title
                Text("Log in")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.yellow)
                
                // Email Field with Validation
                CustomTextField(icon: "envelope", placeholder: "Email", text: $viewModel.email)
                    .focused($focusedField, equals: .email)
                    .onChange(of: focusedField) { newFocus in
                        if newFocus != .email {
                            emailErrorMessage = ValidationHelper.validateEmail(viewModel.email)
                        } else {
                            emailErrorMessage = nil
                        }
                    }
                
                if let emailErrorMessage = emailErrorMessage {
                    Text(emailErrorMessage)
                        .foregroundColor(.red)
                        .font(.subheadline)
                }
                
                // Password Field with Toggle Visibility
                CustomSecureField(icon: "lock", placeholder: "Password", text: $viewModel.password, isSecure: !showPassword, toggle: { showPassword.toggle() })
                    .focused($focusedField, equals: .password)
                
                // Error Message Handling
                if let errorMessage = errorMessage {
                    VStack {
                        Text(errorMessage)
                            .foregroundColor(.red)
                            .padding(.bottom, 5)
                        
                        if showInlineSignUp {
                            HStack {
                                Button("New User? Sign Up") {
                                    navigateToSignUp = true
                                }
                                .foregroundColor(.blue)
                                
                                Spacer()
                                
                                Button("Forgot Password?") {
                                    showForgotPassword = true
                                }
                                .foregroundColor(.blue)
                            }
                        }
                    }
                }
                
                // Sign-In Button
                Button {
                    Task {
                        do {
                            try await viewModel.signIn()
                            errorMessage = nil
                            NavigateToTabsView = true
                        } catch let error as NSError {
                            handleSignInError(error)
                        }
                    }
                } label: {
                    Text("Sign In")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(height: 55)
                        .frame(maxWidth: .infinity)
                        .background(isSignInButtonEnabled ? Color.blue : Color.gray.opacity(0.5))
                        .cornerRadius(10)
                }
                .disabled(!isSignInButtonEnabled)
                
                // OR Separator
                HStack {
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(.gray)
                        .padding(.horizontal, 8)
                    Text("or")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .padding(.horizontal, 8)
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(.gray)
                        .padding(.horizontal, 8)
                }
                .padding(.vertical, 8)
                
                // Social Sign-In Options
                VStack(spacing: 20) {
                    GoogleSignInButton(viewModel: GoogleSignInButtonViewModel(scheme: .dark, style: .wide, state: .normal)) {
                        Task {
                            do {
                                try await viewModel.signInGoogle()
                                NavigateToTabsView = true
                            } catch {
                                print("Google Sign-In Error: \(error)")
                            }
                        }
                    }
                    .frame(height: 55)
                    
                    SignInWithAppleButtonViewRepresentable(type: .default, style: .black)
                        .frame(height: 55)
                }
                
                // Sign-Up Button
                if !showInlineSignUp {
                    Button("Don't have an account? Sign Up") {
                        navigateToSignUp = true
                    }
                    .foregroundColor(.blue)
                    .padding(.top, 10)
                }
                
                Spacer()
                
                // Navigation Links (Hidden)
                NavigationLink(destination: SignUpView().environmentObject(viewModel), isActive: $navigateToSignUp) {
                    EmptyView()
                }
                
                if #available(iOS 18.0, *) {
                    NavigationLink(destination: TabsView(), isActive: $NavigateToTabsView) {
                        EmptyView()
                    }
                } else {
                    // Fallback on earlier versions
                }
                
                Spacer()
                
                // Bottom Navigation Icons
                HStack {
                    if #available(iOS 18.0, *) {
                        NavigationLink(destination: TabsView()) {
                            Image(systemName: "house.fill")
                                .resizable()
                                .frame(width: 40, height: 40)
                                .foregroundColor(.gray)
                        }
                    } else {
                        // Fallback on earlier versions
                    }
                    
                    Spacer()
                    
                    NavigationLink(destination: UserProfileView()) {
                        Image(systemName: "person.crop.circle")
                            .resizable()
                            .frame(width: 40, height: 40)
                            .foregroundColor(.gray)
                    }
                }
                .frame(height: 60)
                .padding(.horizontal)
            }
            .padding()
            .navigationBarTitleDisplayMode(.inline)
            .sheet(isPresented: $showForgotPassword) {
                ForgotPasswordView(email: $viewModel.email, onDismiss: { showForgotPassword = false })
            }
        }
    }
    
    // Function to Handle Sign-In Errors
    private func handleSignInError(_ error: NSError) {
        print("Sign-in error: \(error.domain) - \(error.localizedDescription)")
        switch error.code {
        case 404:
            errorMessage = "Email not registered. Please sign up or try again."
            showInlineSignUp = true
        case 401:
            errorMessage = "Incorrect password. Please try again."
            showInlineSignUp = true
        case 400:
            errorMessage = "Invalid email format. Please check and try again."
            showInlineSignUp = false
        default:
            errorMessage = "An unexpected error occurred."
            showInlineSignUp = true
        }
    }
}



// Apple Sign-In Button Wrapper
struct SignInWithAppleButtonViewRepresentable: UIViewRepresentable {
    let type: ASAuthorizationAppleIDButton.ButtonType
    let style: ASAuthorizationAppleIDButton.Style
    
    func makeUIView(context: Context) -> ASAuthorizationAppleIDButton {
        ASAuthorizationAppleIDButton(authorizationButtonType: type, authorizationButtonStyle: style)
    }
    
    func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {}
}


#Preview {
    UserAuthenticationView(showSignInView: .constant(true))
}


// Content from: ../Equipment Booking/Core/Authentication/Subviews/AuthenticationManager.swift

//
//  AuthenticationManager.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/9/24.
//

import Foundation
import FirebaseAuth

struct AuthDataResultModel {
    let uid: String
    let email: String?
    let photoUrl: String?
    let isAnonymous: Bool
    
    // for profile data fetching

    let dateCreated : Date?
    let isAdmin : Bool?
    let firstName : String?
    let lastName : String?
    let phone : String?
    let address : String?
    let companyName :String?
    let profession : String?
    
    
    
    init(user: User) {
        self.uid = user.uid
        self.email = user.email
        self.photoUrl = user.photoURL?.absoluteString
        self.isAnonymous = user.isAnonymous
        self.dateCreated = user.metadata.creationDate
        self.isAdmin = nil
        self.firstName = nil
        self.lastName = nil
        self.phone = nil
        self.address = nil
        self.companyName = nil
        self.profession = nil
        
    }
    
}

enum AuthProvideroption: String {
    case email = "password"
    case google = "google.com"
    case apple = "apple.com"
}


final class AuthenticationManager {
    static let shared  = AuthenticationManager()
    private init () {}
    
    // Function to get user
    
    func getAuthenticatedUser() throws -> AuthDataResultModel {
        guard let user = Auth.auth().currentUser else {
            throw URLError(.badServerResponse)
        }
        return AuthDataResultModel(user: user)
    }
    
    // Function to get provider service for sign in
    // allows to select what to show after successful login
    
    
    // Provider function (login method)
    
    func getProviders() throws  -> [AuthProvideroption] {
        guard let providerData = Auth.auth().currentUser?.providerData else {
            throw URLError(.badServerResponse)
        }
        
        var providers: [AuthProvideroption] = []
        for provider in providerData {
            if  let option = AuthProvideroption(rawValue: provider.providerID) {
                providers.append(option)
                
            } else {
                assertionFailure("Provide option not found: \(provider.providerID)")
            }
            //
        }
        return providers
        
    }
    
    
    //Function to sign out
    
    func signOut () throws {
        try Auth.auth().signOut()
        
    }
    
}

// MARK: SIGN IN EMAIL/PASSWORD

extension AuthenticationManager{
    // creates a user , not leaving the user logged in.
    @discardableResult
    func createUser(email: String, password: String) async throws -> AuthDataResultModel {
        // Temporarily create a user
        let authDataResult = try await Auth.auth().createUser(withEmail: email, password: password)

        // Save user details to the database (optional, depends on your app's requirements)
        let user = AuthDataResultModel(user: authDataResult.user)
        
        // Add the user to your Firestore database or wherever you're managing users
        let userModel = AuthDataResultModel(user: authDataResult.user)
        try await UserManager.shared.createNewUser(user: DBUser(auth: userModel))

        //try await UserManager.shared.createNewUser(user: DBUser(auth: authDataResult.user))
                
        
        
        // Immediately sign the user out after creation
        try await Auth.auth().signOut()
        
        return user // Return user details without leaving them signed in
        
    }
    
    
// Sign in user function with security verification
    @discardableResult
    func signInUser(email: String, password: String) async throws -> AuthDataResultModel {
        let normalizedEmail = email.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()

        // try signing in, and handle errors properly
        do {
            let authDataResult = try await Auth.auth().signIn(withEmail: normalizedEmail, password: password)
            return AuthDataResultModel(user: authDataResult.user)
        } catch let error as NSError {
            switch error.code {
            case AuthErrorCode.wrongPassword.rawValue:
                throw NSError(domain: "InvalidPassword", code: 401, userInfo: [NSLocalizedDescriptionKey: "Password is incorrect."])
            default:
                throw error
            }
        }
    }

    

    //Function to reset password
    func resetPassword (email: String) async throws {
        try await Auth.auth().sendPasswordReset(withEmail: email)
    }
    
    //Function to update password
    func updatePassword (password: String) async throws {
        guard let user = Auth.auth().currentUser else {
            throw URLError (.badServerResponse)
        }
        try await user.updatePassword(to: password)
    }
    
    //Function to update email
    func updateEmail (email: String) async throws {
        guard let user = Auth.auth().currentUser else {
            throw URLError (.badServerResponse)
        }
        // try await user.updateEmail(to: email) //deprecated function
        try await user.sendEmailVerification(beforeUpdatingEmail: email)
    }
    
}

// MARK: SIGN IN SSO (GOOGLE & APPLE)

extension AuthenticationManager{
    
    @discardableResult
    // function to sign in with google using auth credentials
    func signInWithGoogle(tokens: GoogleSignInResultModel) async throws -> AuthDataResultModel {
        let credential = GoogleAuthProvider.credential(withIDToken: tokens.idToken, accessToken: tokens.accessToken)
        return try await signIn(credential: credential)
        
    }
    
    func signIn(credential: AuthCredential) async throws -> AuthDataResultModel {
        let authDataResult = try await Auth.auth().signIn(with: credential)
        return AuthDataResultModel(user: authDataResult.user)
        
    }

}


    




// Content from: ../Equipment Booking/Core/Authentication/Subviews/ForgotPasswordView.swift

//
//  ForgotPasswordView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/19/25.
//

import SwiftUI

struct ForgotPasswordView: View {
    @Binding var email: String
    var onDismiss: (() -> Void)? // Callback for dismissing the view

    var body: some View {
        NavigationStack {
            VStack (spacing : 20){
                Text("Reset your password")
                    .font(.title)
                    .fontWeight(.semibold)
                    .foregroundColor(.yellow)
                
//                TextField("Enter your email", text: $email)
//                    .padding()
//                    .background(Color.gray.opacity(0.4))
//                    .cornerRadius(10)
                
               
                Text("Enter the email address registered to your account. You will receive a password reset link shortly!")
                    .font(.headline)
                    .fontWeight(.light)
                    .foregroundColor(.gray)
                
                // Email Field (toDo Validate format!) //
                
                CustomTextField(icon: "envelope", placeholder: "Email", text: $email)
                
                Spacer()

                Button("Send Reset Link") {
                    // Add reset password logic here
                }
                .padding()
                .frame(height: 55)
                .frame(maxWidth: .infinity)
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
                .shadow(radius: 5)

//                Spacer()
            }
            .padding()
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        onDismiss?() // Call dismiss callback
                    }
                }
            }
        }
    }
}



#Preview {
    // Pass a mock binding for the `email` variable in preview
    ForgotPasswordView(email: .constant("test@testing.com"))
}



// Content from: ../Equipment Booking/Core/Authentication/Subviews/SignInGoogleHelper.swift

//
//  SignInGoogleHelper.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/28/24.
//

import Foundation
import GoogleSignIn
import GoogleSignInSwift

struct GoogleSignInResultModel {
    let idToken: String
    let accessToken: String
    let name: String?
    let email: String?
    
    
}

final class SignInGoogleHelper {
    @MainActor
    
    func signIn() async throws -> GoogleSignInResultModel {
        guard let topVC = Utilities.shared.topViewController() else {
            throw URLError(.cannotFindHost)
        }
        let gidSignInresult = try await GIDSignIn.sharedInstance.signIn(withPresenting: topVC)
        
        guard let idToken = gidSignInresult.user.idToken?.tokenString else {
            throw URLError(.badServerResponse)
        }
                
        let accessToken: String = gidSignInresult.user.accessToken.tokenString
        let name = gidSignInresult.user.profile?.name
        let email = gidSignInresult.user.profile?.email
        
        let tokens = GoogleSignInResultModel(idToken: idToken, accessToken: accessToken, name: name, email: email)
        
        return tokens
    }
}


// Content from: ../Equipment Booking/Core/Authentication/Subviews/SignUpView.swift

//
//  SignUpView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/12/25.
//


import SwiftUI

struct SignUpView: View {
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var confirmPassword: String = ""
    @State private var showPassword: Bool = false
    @State private var showConfirmPassword: Bool = false
    @State private var emailErrorMessage: String?
    @State private var confirmPasswordErrorMessage: String?
    @State private var showSuccessAlert: Bool = false
    @State private var navigateToEquipmentListing: Bool = false
    @EnvironmentObject var authViewModel: AuthenticationViewModel
    @Environment(\.presentationMode) var presentationMode
    
    // Focus tracking
    @FocusState private var focusedField: Field?
    
    enum Field {
        case email, password, confirmPassword
    }

    // Computed property to enable/disable Sign Up button
    private var isSignUpButtonEnabled: Bool {
        return emailErrorMessage == nil &&
               !password.isEmpty &&
               !confirmPassword.isEmpty &&
               confirmPasswordErrorMessage == nil
    }
    
    private var backButton: some View {
        Button(action: {
            presentationMode.wrappedValue.dismiss() // Ensure it goes back
        }) {
            HStack {
                Image(systemName: "chevron.left")
//                Text("Back")
            }
            .foregroundColor(Color(UIColor.darkGray))
        }
    }


    var body: some View {
        NavigationStack{
            VStack(spacing: 20) {
                Text("Create Your Account")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.yellow)

                // Email Field (Validate when moving focus away)
                CustomTextField(icon: "envelope", placeholder: "Email", text: $email)
                    .focused($focusedField, equals: .email)
                //  Validate when user leaves the field
                    .onChange(of: focusedField) { newFocus in
                        if newFocus != .email {
                            emailErrorMessage = ValidationHelper.validateEmail(email)
                        }
                        else {
                                    // Reset error message when focus returns to the email field
                                    emailErrorMessage = nil
                                }
                    }

                if let emailErrorMessage = emailErrorMessage {
                    Text(emailErrorMessage)
                        .foregroundColor(.red)
                        .font(.subheadline)
                }

                // Password Field (No inline validation)
                CustomSecureField(icon: "lock", placeholder: "Password", text: $password, isSecure: !showPassword, toggle: { showPassword.toggle() })
                    .focused($focusedField, equals: .password)

                // Confirm Password Field (Validate in real-time)
                CustomSecureField(icon: "lock.fill", placeholder: "Confirm Password", text: $confirmPassword, isSecure: !showConfirmPassword, toggle: { showConfirmPassword.toggle() })
                    .focused($focusedField, equals: .confirmPassword)
                    .onChange(of: confirmPassword) {
                        _ in confirmPasswordErrorMessage = ValidationHelper.validateConfirmPassword(password: password, confirmPassword: confirmPassword) }
                
                // Validate only in Confirm Password field

                if let confirmPasswordErrorMessage = confirmPasswordErrorMessage {
                    Text(confirmPasswordErrorMessage)
                        .foregroundColor(.red)
                        .font(.subheadline)
                }

                // Sign Up Button
                Button(action: handleSignUp) {
                    Text("Sign Up")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(height: 55)
                        .frame(maxWidth: .infinity)
                        .background(isSignUpButtonEnabled ? Color.blue : Color.gray.opacity(0.5))
                        .cornerRadius(12)
                        .shadow(radius: 5)
                }
                .disabled(!isSignUpButtonEnabled)

                Spacer()
            }
            .padding()

            .navigationBarBackButtonHidden(true) // Hide default back button
            .navigationBarItems(leading: backButton)


            .alert("Registration Successful!", isPresented: $showSuccessAlert) {
                Button("OK") {
                    navigateToEquipmentListing = true
                }
            } message: {
                Text("You have successfully signed up and are now logged in.")
            }
            
            NavigationLink(destination: EquipmentListingView(), isActive: $navigateToEquipmentListing) {
                EmptyView()
            }
            .hidden()
            
            
        }

    }
    

    // Sign-Up Logic
    private func handleSignUp() {
        guard isSignUpButtonEnabled else { return }

        Task {
            do {
                try await authViewModel.signUpAndLogin(email: email, password: password)
                showSuccessAlert = true
            } catch {
                emailErrorMessage = error.localizedDescription
            }
        }
    }
}


#Preview {
    SignUpView()
}





// Content from: ../Equipment Booking/Core/Authentication/Subviews/UserSignInEmailView.swift

//
//  UserSignInEmailView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/9/24.
//

import SwiftUI

struct UserSignInEmailView: View {
    @StateObject private var viewModel = SignInEmailViewModel()
    @Binding var showSignInView: Bool
    @Binding var showPassword: Bool
    @State private var errorMessage: String? // For error display
    @State private var showSignUp = false
    @State private var showForgotPassword = false

    var body: some View {
        VStack {
            // Email Field
            TextField("Email...", text: $viewModel.email)
                .padding()
                .background(Color.gray.opacity(0.4))
                .cornerRadius(10)

            // Password Field
            HStack {
                if showPassword {
                    TextField("Password...", text: $viewModel.password)
                } else {
                    SecureField("Password...", text: $viewModel.password)
                }
                Button(action: { showPassword.toggle() }) {
                    Image(systemName: showPassword ? "eye.slash" : "eye")
                        .foregroundColor(.gray)
                }
                .padding(.trailing, 10)
            }
            .padding()
            .background(Color.gray.opacity(0.4))
            .cornerRadius(10)

            // Error Message Display
            if let errorMessage = errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .padding()
            }

            // Sign In Button
            Button {
                Task {
                    do {
                        try await viewModel.signIn()
                        showSignInView = false
                    } catch {
                        // Handle Errors
                        if let error = error as NSError? {
                            if error.domain == "EmailNotRegistered" {
                                errorMessage = "Email not registered. Please sign up or try again."
                            } else if error.domain == "InvalidPassword" {
                                errorMessage = "Incorrect password. Please try again or reset it."
                            } else {
                                errorMessage = "An unknown error occurred."
                            }
                        }
                    }
                }
            } label: {
                Text("Sign In")
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(height: 55)
                    .frame(maxWidth: .infinity)
                    .background(Color.blue)
                    .cornerRadius(10)
            }

            // Options for Recovery
            HStack {
                Button("Sign Up") {
                    showSignUp = true
                }
                .foregroundColor(.blue)
                .padding()

                Button("Forgot Password") {
                    showForgotPassword = true
                }
                .foregroundColor(.blue)
                .padding()
            }
        }
        .padding()
        .sheet(isPresented: $showSignUp) {
            SignUpView()
        }
        .sheet(isPresented: $showForgotPassword) {
            ForgotPasswordView(email: $viewModel.email) // Pass the binding properly
        }

    }
}

struct UserSignInEmailView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            UserSignInEmailView(showSignInView: .constant(false), showPassword: .constant(false))
        }
    }
}





// Content from: ../Equipment Booking/Core/Authentication/Subviews/UserSignInEmailViewModel.swift

//
//  UserSignInEmailViewModel.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/29/24.
//

import Foundation

@MainActor

final class SignInEmailViewModel: ObservableObject {
    @Published var  email = ""
    @Published var  password = ""
    
    // User signup function
    
    func signUp() async throws {
        guard !email.isEmpty, !password.isEmpty else {
            print("No email or password found!")
            return
        }
        
        let authDataResult = try await AuthenticationManager.shared.createUser(email: email, password: password)
        let user = DBUser(auth: authDataResult)
        try await UserManager.shared.createNewUser(user: user)
        
    }
    
    func signIn() async throws {
        guard !email.isEmpty, !password.isEmpty else {
            print("No email or password found!")
            return
        }
        
        try await AuthenticationManager.shared.signInUser(email: email, password: password)
        
    }
    
}


// Content from: ../Equipment Booking/Core/Equipments/EquipmentListingView.swift

//
//  EquipmentListingView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/6/25.
//

import SwiftUI
import Firebase
import FirebaseFirestore

struct EquipmentListingView: View {
    @StateObject private var viewModel = EquipmentListingViewModel()
    @State private var searchText: String = ""
    @State private var selectedCategory: String = "All"
    @State private var navigateToCart = false // State to control cart navigation

    // Filtered Equipment List
    var filteredEquipments: [Equipment] {
        viewModel.equipments.filter { equipment in
            (selectedCategory == "All" || equipment.equipment_main_category == selectedCategory) &&
            (searchText.isEmpty || equipment.equipment_name?.localizedCaseInsensitiveContains(searchText) == true)
        }
    }

    var body: some View {
        NavigationView {
            VStack {
                // Search and Filter
                HStack {
                    TextField("Search equipment...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .padding(.horizontal)

                    Menu {
                        Button("All", action: { selectedCategory = "All" })
                        Button("Construction Cranes", action: { selectedCategory = "Construction Cranes" })
                        Button("Power Tools", action: { selectedCategory = "Power Tools" })
                    } label: {
                        HStack {
                            Text(selectedCategory)
                                .font(.subheadline)
                                .foregroundColor(.blue)
                            Image(systemName: "arrowtriangle.down.fill")
                                .font(.caption)
                                .foregroundColor(.blue)
                        }
                        .padding(.trailing)
                    }
                }
                .padding(.top)

                // Equipment List
                List {
                    ForEach(filteredEquipments) { equipment in
                        HStack(alignment: .top) {
                            // Equipment Image
                            AsyncImage(url: URL(string: equipment.img_url ?? "")) { image in
                                image.resizable()
                                    .scaledToFit()
                                    .frame(width: 100, height: 100)
                                    .cornerRadius(10)
                            } placeholder: {
                                ProgressView()
                            }
                            .shadow(radius: 10)

                            // Equipment Details
                            VStack(alignment: .leading, spacing: 4) {
                                Text(equipment.equipment_name ?? "n/a")
                                    .font(.headline)
                                    .foregroundColor(.primary)

                                Text(equipment.description ?? "No description available")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)

                                if equipment.availability_status == "available" {
                                    Button(action: {
                                        addToCart(equipment: equipment)
                                    }) {
                                        Text("Add to Cart")
                                            .font(.caption)
                                            .foregroundColor(.blue)
                                            .padding(5)
                                            .background(Color.gray.opacity(0.2))
                                            .cornerRadius(5)
                                    }
                                } else if equipment.availability_status == "rented" {
                                    Text("Expected Return: yyyy-mm-dd")
                                        .font(.caption)
                                        .foregroundColor(.red)
                                }
                            }
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())

                Spacer()

                // Footer Section with Home, Cart, and Profile Buttons
                HStack {
                    // Home Button - Reloads Equipment List
                    Button(action: {
                        Task {
                            try await viewModel.fetchEquipments() // Reloads the equipment list
                        }
                    }) {
                        Image(systemName: "house.fill")
                            .resizable()
                            .frame(width: 30, height: 30)
                            .foregroundColor(.blue)
                    }

                    Spacer()

                    // Cart Button - Navigates to Empty Cart View
                    NavigationLink(destination: CartView(), isActive: $navigateToCart) {
                        Button(action: { navigateToCart = true }) {
                            Image(systemName: "cart")
                                .resizable()
                                .frame(width: 30, height: 30)
                                .foregroundColor(.blue)
                        }
                    }

                    Spacer()

                    // User Profile Button (Moved from Toolbar to Footer)
                    NavigationLink(destination: UserProfileView()) {
                        Image(systemName: "person.crop.circle")
                            .resizable()
                            .frame(width: 30, height: 30)
                            .foregroundColor(.blue)
                    }
                }
                .frame(height: 60)
                .padding(.horizontal)
            }
            .navigationTitle("Equipment List")
            .navigationBarTitleDisplayMode(.inline)
            .task {
                try? await viewModel.fetchEquipments()
            }
        }
    }

    // Function to Handle Adding to Cart
    private func addToCart(equipment: Equipment) {
        guard let authUser = try? AuthenticationManager.shared.getAuthenticatedUser() else { return }

        // Generate Booking ID
        let bookingID = EquipmentManager.shared.generateBookingID(firstName: authUser.firstName ?? "Guest", lastName: authUser.lastName ?? "User")

        // Create Rental Data
        let rental: [String: Any] = [
            "Date_out": Date(),
            "rented_items": [equipment.equip_id],
            "expected_return_date": Calendar.current.date(byAdding: .day, value: 7, to: Date()) ?? Date(),
            "user_id": authUser.uid
        ]

        // Save to Firebase Rentals Collection
        Firestore.firestore().collection("rentals").document(bookingID).setData(rental) { error in
            if let error = error {
                print("Error adding rental: \(error)")
                return
            }

            // Update Equipment Status to "booked"
            Firestore.firestore().collection("equipments").document(equipment.equip_id).updateData(["availability_status": "booked"]) { error in
                if let error = error {
                    print("Error updating equipment status: \(error)")
                }
            }
        }
    }
}

// Placeholder Cart View
struct CartView_2: View {
    @Environment(\.presentationMode) var presentationMode // For back navigation

    var body: some View {
        NavigationStack {
            VStack {
                Text("Cart is Empty")
                    .font(.title)
                    .padding()

                Spacer()

                // Footer Section with Home and Profile Buttons
                HStack {
                    // Home Button - Navigate Back to EquipmentListingView
                    NavigationLink(destination: EquipmentListingView()) {
                        Image(systemName: "house.fill")
                            .resizable()
                            .frame(width: 30, height: 30)
                            .foregroundColor(.blue)
                    }

                    Spacer()

                    // User Profile Button
                    NavigationLink(destination: UserProfileView()) {
                        Image(systemName: "person.crop.circle")
                            .resizable()
                            .frame(width: 30, height: 30)
                            .foregroundColor(.blue)
                    }
                }
                .frame(height: 60)
                .padding()
            }
            .navigationTitle("Cart")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

struct EquipmentListingView_Previews: PreviewProvider {
    static var previews: some View {
        if #available(iOS 16.0, *) {
            NavigationStack {
                EquipmentListingView()
            }
        } else {
            // Fallback on earlier versions
        }
    }
}



// Content from: ../Equipment Booking/Core/Equipments/EquipmentListingViewModel.swift

//
//  EquipmentListingViewModel.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/6/25.
//

import Foundation
import Firebase
import FirebaseFirestore

@MainActor
final class EquipmentListingViewModel: ObservableObject {
    
    @Published var equipments: [Equipment] = []
    
    private var db = Firestore.firestore()
      
    
    func fetchEquipments() {
        db.collection("equipments").getDocuments {
            (snapshot, error) in
            if let error = error {
                print("Error fetching equipments: \(error)")
                return
                
            }
            
            guard let documents = snapshot?.documents else {
                print("No document found")
                
                return
            }
            
            self.equipments = documents.compactMap { document -> Equipment? in
                let data = document.data()

                // Safely unwrap and cast each field
                let equip_id = data["equip_id"] as? String ?? "unknown"
                let availability_status = data["availability_status"] as? String
                let description = data["description"] as? String
                let equipment_main_category = data["equipment_main_category"] as? String
                let equipment_sub_category = data["equipment_sub_category"] as? String
                let equipment_name = data["equipment_name"] as? String
                let img_name = data["img_name"] as? String
                let img_url = data["img_url"] as? String
                let manufacturer = data["manufacturer"] as? String

                // Handle rental_price_per_day as Double? or nil
                var rental_price_per_day: Double? = nil
                if let price = data["rental_price_per_day"] as? Double {
                    rental_price_per_day = price
                } else if let priceString = data["rental_price_per_day"] as? String, let price = Double(priceString) {
                    rental_price_per_day = price
                }

                return Equipment(
                    equip_id: equip_id,
                    availability_status: availability_status,
                    description: description,
                    equipment_main_category: equipment_main_category,
                    equipment_sub_category: equipment_sub_category,
                    equipment_name: equipment_name,
                    img_name: img_name,
                    img_url: img_url,
                    manufacturer: manufacturer,
                    rental_price_per_day: rental_price_per_day
                )
            }
            
            
        }
        
        
    }
    
    //Booking ID Generation Function:
    
    func generateBookingID(firstName: String, lastName: String) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyyMMdd_HHmm"
        let dateStr = dateFormatter.string(from: Date())
        let id = "\(firstName.prefix(1))\(lastName.prefix(2).uppercased())\(dateStr)"
        return id
    }
    
}



// Content from: ../Equipment Booking/Core/Firestore/EquipmentsManager.swift

//
//  EquipmentsManager.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/6/25.
//

import Foundation
import FirebaseFirestore
import FirebaseFirestoreCombineSwift

@MainActor
final class EquipmentManager: ObservableObject {
    
    static let shared = EquipmentManager()
    private init() {}
    
    private let equipmentsCollection = Firestore.firestore().collection("equipments")
    
    //function to get document/equipment for a given equipmentId
    private func equipmentDocument(equipmentId: String) -> DocumentReference {
        equipmentsCollection.document(equipmentId)
    }
    
    func uploadEquipment(equipment: Equipment) async throws {
        try equipmentDocument(equipmentId: equipment.equip_id).setData(from: equipment, merge: false)
    }
    
    func getAllEquipments() async throws -> [Equipment] {
        let snapshot = try await equipmentsCollection.getDocuments()
        
        var equipments: [Equipment] = []
        for document in snapshot.documents {
            let equipment = try document.data(as: Equipment.self)
            equipments.append(equipment)
        }
        
        return equipments
        
    }
    
    //Booking ID Generation Function:
    
    func generateBookingID(firstName: String, lastName: String) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyyMMdd_HHmm"
        let dateStr = dateFormatter.string(from: Date())
        let id = "\(firstName.prefix(1))\(lastName.prefix(2).uppercased())\(dateStr)"
        return id
    }
}


// Content from: ../Equipment Booking/Core/Firestore/UserManager.swift

//
//  UserManager.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/29/24.
//

import Foundation
import FirebaseFirestore
import FirebaseFirestoreCombineSwift


//struct DBUser: Codable {
//    let userId: String
//    let isAnonymous: Bool?
//    let email: String?
//    let photoUrl: String?
//    let dateCreated: Date?
//    let isAdmin: Bool?
//    let firstName: String?
//    let lastName: String?
//    let phone: String?          // New field
//    let address: String?        // New field
//    let companyName: String?    // New field
//    let profession: String?     // New field
//
//    init(auth: AuthDataResultModel) {
//        self.userId = auth.uid
//        self.isAnonymous = auth.isAnonymous
//        self.email = auth.email
//        self.photoUrl = auth.photoUrl
//        self.dateCreated = Date()
//        self.isAdmin = false
//        self.firstName = auth.firstName
//        self.lastName = auth.lastName
//        self.phone = ""
//        self.address = ""
//        self.companyName = ""
//        self.profession = ""
//    }
//
//    enum CodingKeys: String, CodingKey {
//        case userId = "doc_id"
//        case isAnonymous = "is_anonymous"
//        case email = "email"
//        case photoUrl = "img_url"
//        case dateCreated = "date_created"
//        case isAdmin = "is_admin"
//        case firstName = "firstname"
//        case lastName = "lastname"
//        case phone = "phone"
//        case address = "address"
//        case companyName = "company_name"
//        case profession = "profession"
//    }
//}


struct DBUser: Codable {
    let userId: String
    let isAnonymous: Bool?
    let email: String?
    let photoUrl: String? // Corresponds to 'img_url'
    let dateCreated: Date? // Optional, as Firestore does not provide this by default
    let isAdmin: Bool? // Corresponds to 'is_admin', decoded from both string and boolean
    let firstName: String? // Corresponds to 'firstname'
    let lastName: String? // Corresponds to 'lastname'
    let phone: String?
    let address: String?
    let companyName: String?
    let profession: String?
    

    init(auth: AuthDataResultModel) {
        self.userId = auth.uid
        self.isAnonymous = auth.isAnonymous
        self.email = auth.email
        self.photoUrl = auth.photoUrl
        self.dateCreated = Date() // Placeholder, as Firestore does not include dateCreated
        self.isAdmin = false // Default to false for new users
        self.firstName = auth.firstName ?? ""
        self.lastName = auth.lastName ?? ""
        self.phone = auth.phone ?? ""
        self.address = auth.address ?? ""
        self.companyName = auth.companyName ?? ""
        self.profession = auth.profession ?? ""
    }

    init(
        userId: String,
        isAnonymous: Bool? = nil,
        email: String? = nil,
        photoUrl: String? = nil,
        dateCreated: Date? = nil,
        isAdmin: Bool? = nil,
        firstName: String? = nil,
        lastName: String? = nil,
        phone: String? = nil,
        address: String? = nil,
        companyName: String? = nil,
        profession: String? = nil
        
        
    ) {
        self.userId = userId
        self.isAnonymous = isAnonymous
        self.email = email
        self.photoUrl = photoUrl
        self.dateCreated = dateCreated
        self.isAdmin = isAdmin
        self.firstName = firstName
        self.lastName = lastName
        self.phone = phone
        self.address = address
        self.companyName = companyName
        self.profession = profession
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.userId = try container.decode(String.self, forKey: .userId)
        self.isAnonymous = try container.decodeIfPresent(Bool.self, forKey: .isAnonymous)
        self.email = try container.decodeIfPresent(String.self, forKey: .email)
        self.photoUrl = try container.decodeIfPresent(String.self, forKey: .photoUrl)
        self.dateCreated = try container.decodeIfPresent(Date.self, forKey: .dateCreated)
        
        // Decode 'is_admin' as either Bool or String
        if let isAdminBool = try? container.decode(Bool.self, forKey: .isAdmin) {
            self.isAdmin = isAdminBool
        } else if let isAdminString = try? container.decode(String.self, forKey: .isAdmin), let isAdminBool = Bool(isAdminString) {
            self.isAdmin = isAdminBool
        } else {
            self.isAdmin = nil
        }

        self.firstName = try container.decodeIfPresent(String.self, forKey: .firstName)
        self.lastName = try container.decodeIfPresent(String.self, forKey: .lastName)
        self.phone = try container.decodeIfPresent(String.self, forKey: .phone)
        self.address = try container.decodeIfPresent(String.self, forKey: .address)
        self.companyName = try container.decodeIfPresent(String.self, forKey: .companyName)
        self.profession = try container.decodeIfPresent(String.self, forKey: .profession)
    }

    enum CodingKeys: String, CodingKey {
        case userId = "doc_id"
        case isAnonymous = "is_anonymous"
        case email = "email"
        case photoUrl = "img_url"
        case dateCreated = "date_created"
        case isAdmin = "is_admin" // Matches 'is_admin' in Firestore
        case firstName = "firstname"
        case lastName = "lastname"
        case phone = "phone"
        case address = "address"
        case companyName = "company_name" // Matches 'companty_name' in Firestore
        case profession = "profession"
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.userId, forKey: .userId)
        try container.encodeIfPresent(self.isAnonymous, forKey: .isAnonymous)
        try container.encodeIfPresent(self.email, forKey: .email)
        try container.encodeIfPresent(self.photoUrl, forKey: .photoUrl)
        try container.encodeIfPresent(self.dateCreated, forKey: .dateCreated)
        try container.encodeIfPresent(self.isAdmin, forKey: .isAdmin)
        try container.encodeIfPresent(self.firstName, forKey: .firstName)
        try container.encodeIfPresent(self.lastName, forKey: .lastName)
        try container.encodeIfPresent(self.phone, forKey: .phone)
        try container.encodeIfPresent(self.address, forKey: .address)
        try container.encodeIfPresent(self.companyName, forKey: .companyName)
        try container.encodeIfPresent(self.profession, forKey: .profession)
    }
}



final class UserManager {
    
    static let shared = UserManager()
    private init() {}
    
    private let userCollection = Firestore.firestore().collection("users")
    
    //function to get document/user for a given userID
    private func userDocument(userId: String) -> DocumentReference {
        userCollection.document(userId)
    }


    
    func createNewUser(user: DBUser) async  throws {
        try userDocument(userId: user.userId).setData(from: user, merge: false )
        
    }
    
    func getUser(userID: String) async throws -> DBUser {
        let documentSnapshot = try await userDocument(userId: userID).getDocument()
        print("Raw Firestore data: \(documentSnapshot.data() ?? [:])") // Debugging line

        do {
            return try documentSnapshot.data(as: DBUser.self) // Decode to DBUser format
        } catch {
            print("Decoding error: \(error)")
            throw error
        }
    }


    
//    func getUser(userID: String) async throws -> DBUser {
//        try await userDocument(userId: userID).getDocument(as: DBUser.self ) //Decode to DBUser format
//        
//    }
     
    
    func updateUserAdminStatus(userId: String, isAdmin: Bool) async throws {
        let data: [String:Any] = [
            DBUser.CodingKeys.isAdmin.rawValue: isAdmin
        ]
        try userDocument(userId: userId).updateData(data)
    }
    
}


// Content from: ../Equipment Booking/Core/Profile/ProfileView.swift

//
//  ProfileView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/29/24.
//


import SwiftUI

@MainActor

final class ProfileViewModel: ObservableObject {
    
    @Published private(set) var user: DBUser? = nil
    
    func loadCurrentUser() async throws {
        let authDataResult = try AuthenticationManager.shared.getAuthenticatedUser()
        self.user = try await UserManager.shared.getUser(userID: authDataResult.uid)
    }
    
    func toggleAdminStatus(){
        guard let user else {return}
        let currentValue = user.isAdmin ?? false
        
        
//        let currentValue = user.isAdmin ?? false
//        let updatedUser = DBUser(userId: user.userId, isAnonymous: user.isAnonymous, email: user.email, photoUrl: user.photoUrl, dateCreated: user.dateCreated, isAdmin: !currentValue)
        //let updatedUser = user.toggleAdminStatus()
        
        Task{
            try await UserManager.shared.updateUserAdminStatus(userId: user.userId, isAdmin:!currentValue)
            self.user = try await UserManager.shared.getUser(userID: user.userId)
        }
        
    }
    
}

struct ProfileView: View {
    
    @StateObject private var viewModel = ProfileViewModel()
    @Binding var showSignInView: Bool
    
    
    var body: some View {
        List {
            
            if let user = viewModel.user {
                Text("userID: \(user.userId)")
                
                if let isAnonymous = user.isAnonymous{
                    Text("Is Anonymous: \(isAnonymous.description.capitalized)")
                }
                
                Button{
                    viewModel.toggleAdminStatus()
                    
                } label: {
                    Text("User is Admin: \((user.isAdmin ?? false).description.capitalized)")
                }
            }
            
            
        }
        .task {
            try? await viewModel.loadCurrentUser()
            
        }
        .navigationTitle("Profile")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                NavigationLink{
                    UserSettingsView(showSignInView: $showSignInView)
                } label: {
                    Image(systemName: "gear")
                        .font(.headline)
                }
                
                
            }
        }
        Spacer()
        
        NavigationView {
            VStack{
                NavigationLink (destination: EquipmentListingView()) {
                    
                    Text("Go to Equipment Listing")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(height: 55)
                        .frame(maxWidth: .infinity)
                        .background(Color.green)
                        .cornerRadius(10)
                    
                }
                
            }
            .navigationTitle("Equipment Listing")
        }
                
    }
}

#Preview {
    NavigationStack {
        ProfileView(showSignInView: .constant(false))
    }
    
}


// Content from: ../Equipment Booking/Core/Profile/UserProfileEditView.swift

//
//  UserProfileEditView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/20/25.
//

import SwiftUI
import Firebase

struct UserProfileEditView: View {
    @StateObject private var viewModel = UserProfileViewModel()
    @Environment(\.presentationMode) var presentationMode
    
    @State private var firstName: String = ""
    @State private var lastName: String = ""
    @State private var phone: String = ""
    @State private var address: String = ""
    @State private var companyName: String = ""
    @State private var profession: String = ""
    
    @State private var isEditing: Bool = false
    @State private var errorMessage: String?
    
    var body: some View {
        NavigationStack {
            Form {
                // User Information Section
                Section(header: Text("User Information")) {
                    TextField("First Name", text: $firstName)
                        .disabled(!isEditing)
                    
                    TextField("Last Name", text: $lastName)
                        .disabled(!isEditing)
                    
                    Text(viewModel.user?.email ?? "No Email") // Email (non-editable)
                        .foregroundColor(.gray)
                }
                
                // Additional Attributes
                Section(header: Text("Additional Details")) {
                    TextField("Phone Number", text: $phone)
                        .disabled(!isEditing)
                    
                    TextField("Mailing Address", text: $address)
                        .disabled(!isEditing)
                    
                    TextField("Company Name", text: $companyName)
                        .disabled(!isEditing)
                    
                    TextField("Profession", text: $profession)
                        .disabled(!isEditing)
                }
                
                // Edit & Save Button
                Section {
                    if isEditing {
                        Button("Save Changes") {
                            saveProfileChanges()
                        }
                        .foregroundColor(.green)
                    } else {
                        Button("Edit Profile") {
                            isEditing.toggle()
                        }
                        .foregroundColor(.blue)
                    }
                }
            }
            .navigationTitle("Edit Profile")
            .onAppear {
                loadUserData()
            }
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        presentationMode.wrappedValue.dismiss()
                    }
                }
            }
        }
    }
    
    // Load user data from Firestore
    private func loadUserData() {
        Task {
            await viewModel.loadCurrentUser()
            if let user = viewModel.user {
                firstName = user.firstName ?? ""
                lastName = user.lastName ?? ""
                phone = user.phone ?? ""
                address = user.address ?? ""
                companyName = user.companyName ?? ""
                profession = user.profession ?? ""
            }
        }
    }
    
    // Save user changes to Firestore
    private func saveProfileChanges() {
        Task {
            do {
                try await viewModel.updateUserProfile(
                    firstName: firstName,
                    lastName: lastName,
                    phone: phone,
                    address: address,
                    companyName: companyName,
                    profession: profession
                )
                isEditing = false
            } catch {
                errorMessage = "Failed to update profile: \(error.localizedDescription)"
            }
        }
    }
}



// Content from: ../Equipment Booking/Core/Profile/UserProfileView.swift

//
//  UserProfileView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/18/25.
//
// UserProfileView
import SwiftUI
import FirebaseAuth
import FirebaseFirestore

struct UserProfileView: View {
    @StateObject private var viewModel = UserProfileViewModel()
    @Environment(\.presentationMode) var presentationMode
    @State private var navigateToSignIn = false
    @State private var navigateToSettings = false // âœ… Separate state for settings

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                if let user = viewModel.user {
                    // Profile Image
                    AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
                        image.resizable()
                            .frame(width: 100, height: 100)
                            .clipShape(Circle())
                            .padding(.top)
                    } placeholder: {
                        Image(systemName: "person.crop.circle.fill")
                            .resizable()
                            .frame(width: 100, height: 100)
                            .foregroundColor(.yellow)
                            .padding(.top)
                    }

                    // Display user's name or email
                    Text(user.firstName ?? user.email ?? "Anonymous User")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)

                    Divider().padding(.vertical)

                    // Menu Items
                    VStack(spacing: 15) {
                        ProfileMenuItem(icon: "list.bullet.rectangle", text: "My Rentals") {
                            print("My Rentals tapped")
                        }

                        // âœ… Correct binding for navigation
                        // âœ… Correct NavigationLink usage
                        NavigationLink(destination: UserSettingsView(showSignInView: $navigateToSignIn)) {
                            ProfileMenuItem(icon: "gearshape", text: "Settings")
                        }
                        .buttonStyle(PlainButtonStyle()) // Remove button style from the NavigationLink

//                        NavigationLink(destination: UserSettingsView(showSignInView: $navigateToSignIn), isActive: $navigateToSettings) {
//                            ProfileMenuItem(icon: "gearshape", text: "Settings")
//                        }
//                        .buttonStyle(PlainButtonStyle())

                        ProfileMenuItem(icon: "phone.fill", text: "Contact Us") {
                            print("Support tapped")
                        }

                        ProfileMenuItem(icon: "doc.text.fill", text: "Privacy & Policy") {
                            print("Privacy & Policy tapped")
                        }
                    }
                    .padding(.horizontal, 20)
                } else {
                    ProgressView("Loading user data...")
                        .task {
                            await viewModel.loadCurrentUser()
                        }
                }
                
                Spacer()

                // Logout Button
                Button {
                    Task {
                        do {
                            try AuthenticationManager.shared.signOut()
                            navigateToSignIn = true
                        } catch {
                            print("Error during sign-out: \(error)")
                        }
                    }
                } label: {
                    Text("Log out")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(height: 55)
                        .frame(maxWidth: .infinity)
                        .background(Color.red)
                        .cornerRadius(10)
                        .shadow(radius: 5)
                }
                .padding(.horizontal, 20)
            }
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Image(systemName: "chevron.left")
                            .font(.headline)
                            .foregroundColor(.yellow)
                    }
                }
            }
//            // âœ… Navigation for Settings (fixed)
//            .navigationDestination(isPresented: $navigateToSettings) {
//                UserSettingsView(showSignInView: $navigateToSignIn)
            }

            
        // âœ… Navigation for Sign-in (Separate)
        .navigationDestination(isPresented: $navigateToSignIn) {
            UserAuthenticationView(showSignInView: $navigateToSignIn)
        }
    }
}



// Reusable Profile Menu Item
struct ProfileMenuItem: View {
    let icon: String
    let text: String
    var action: (() -> Void)? = nil

    var body: some View {
        Button(action: { action?() }) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(.yellow)
                    .font(.headline)
                Text(text)
                    .font(.headline)
                    .foregroundColor(.black)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
            .padding()
            .background(RoundedRectangle(cornerRadius: 12).fill(Color.yellow.opacity(0.2)))
            .shadow(radius: 2)
        }
    }
}

#Preview {
    UserProfileView()
}





//import SwiftUI
//import FirebaseAuth
//import FirebaseFirestore
////
//// UserProfileView
//
//struct UserProfileView: View {
//    @StateObject private var viewModel = UserProfileViewModel()
//    @Environment(\.presentationMode) var presentationMode
//    @State private var navigateToSignIn = false // State for sign-in navigation
//    @State private var navigateToSettings = false // State for settings navigation
//
//    var body: some View {
//        NavigationStack {
//            VStack(spacing: 20) {
//                if let user = viewModel.user {
//                    // User Profile Image
//                    AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
//                        image.resizable()
//                            .frame(width: 100, height: 100)
//                            .clipShape(Circle())
//                            .padding(.top)
//                    } placeholder: {
//                        Image(systemName: "person.crop.circle.fill")
//                            .resizable()
//                            .frame(width: 100, height: 100)
//                            .foregroundColor(.yellow)
//                            .padding(.top)
//                    }
//
//                    // Display user's name or email if name is missing
//                    Text(user.firstName ?? user.email ?? "Anonymous User")
//                        .font(.title2)
//                        .fontWeight(.bold)
//                        .foregroundColor(.black)
//
//                    Divider().padding(.vertical)
//
//                    // Menu Items
//                    VStack(spacing: 15) {
//                        ProfileMenuItem(icon: "list.bullet.rectangle", text: "My Rentals") {
//                            print("My Rentals tapped")
//                        }
//
//                        // Navigate to Settings View
//                        Button {
//                            navigateToSettings = true
//                        } label: {
//                            ProfileMenuItem(icon: "gearshape", text: "Settings")
//                        }
//
//                        ProfileMenuItem(icon: "phone.fill", text: "Contact Us") {
//                            print("Support tapped")
//                        }
//
//                        ProfileMenuItem(icon: "doc.text.fill", text: "Privacy & Policy") {
//                            print("Privacy & Policy tapped")
//                        }
//                    }
//                    .padding(.horizontal, 20)
//                } else {
//                    ProgressView("Loading user data...")
//                        .task {
//                            await viewModel.loadCurrentUser()
//                        }
//                }
//                
//                Spacer()
//
//                // Logout Button
//                Button {
//                    Task {
//                        do {
//                            try AuthenticationManager.shared.signOut()
//                            navigateToSignIn = true
//                        } catch {
//                            print("Error during sign-out: \(error)")
//                        }
//                    }
//                } label: {
//                    Text("Log out")
//                        .font(.headline)
//                        .foregroundColor(.white)
//                        .frame(height: 55)
//                        .frame(maxWidth: .infinity)
//                        .background(Color.red)
//                        .cornerRadius(10)
//                        .shadow(radius: 5)
//                }
//                .padding(.horizontal, 20)
//            }
//            .navigationBarBackButtonHidden(true)
//            .toolbar {
//                ToolbarItem(placement: .navigationBarLeading) {
//                    Button(action: {
//                        presentationMode.wrappedValue.dismiss()
//                    }) {
//                        Image(systemName: "chevron.left")
//                            .font(.headline)
//                            .foregroundColor(.yellow)
//                    }
//                }
//            }
//            // âœ… Navigate to Settings
//            .navigationDestination(isPresented: $navigateToSettings) {
//                UserSettingsView(showSignInView: $navigateToSettings)
//            }
//
//            // âœ… Navigate to Sign-in View
//            .navigationDestination(isPresented: $navigateToSignIn) {
//                UserAuthenticationView(showSignInView: $navigateToSignIn)
//            }
//        }
//    }
//}
//
//// Reusable Profile Menu Item
//struct ProfileMenuItem: View {
//    let icon: String
//    let text: String
//    var action: (() -> Void)? = nil
//
//    var body: some View {
//        Button(action: { action?() }) {
//            HStack {
//                Image(systemName: icon)
//                    .foregroundColor(.yellow)
//                    .font(.headline)
//                Text(text)
//                    .font(.headline)
//                    .foregroundColor(.black)
//                Spacer()
//                Image(systemName: "chevron.right")
//                    .foregroundColor(.gray)
//            }
//            .padding()
//            .background(RoundedRectangle(cornerRadius: 12).fill(Color.yellow.opacity(0.2)))
//            .shadow(radius: 2)
//        }
//    }
//}
//
//#Preview {
//    UserProfileView()
//}


//struct UserProfileView: View {
//    @StateObject private var viewModel = UserProfileViewModel()
//    @Environment(\.presentationMode) var presentationMode
//    @State private var navigateToSignIn = false // State to trigger navigation
//
//    var body: some View {
//        NavigationStack {
//            VStack (spacing: 20){
//                if let user = viewModel.user {
//                    // User Profile Image
//                    AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
//                        image.resizable()
//                            .frame(width: 100, height: 100)
//                            .clipShape(Circle())
//                            .padding(.top)
//                    } placeholder: {
//                        Image(systemName: "person.crop.circle.fill")
//                            .resizable()
//                            .frame(width: 100, height: 100)
//                            .foregroundColor(.yellow)
//                            .padding(.top)
//                    }
//
//                    // Display user's name or email if name is missing
//                    Text(user.firstName ?? user.email ?? "Anonymous User")
//                        .font(.title2)
//                        .fontWeight(.bold)
//                        .foregroundColor(.black)
//
//                    Divider()
//                        .padding(.vertical)
//
//                    // Menu Items with yellow theme
//                    VStack(spacing: 15) {
//                        ProfileMenuItem(icon: "list.bullet.rectangle", text: "My Rentals") {
//                            print("My Rentals tapped")
//                        }
//                        
//                        NavigationLink(destination: UserSettingsView(showSignInView: $navigateToSignIn)) {
//                            ProfileMenuItem(icon: "gearshape", text: "Settings")
//                        }
//                        
//                        ProfileMenuItem(icon: "phone.fill", text: "Contact Us") {
//                            print("Support tapped")
//                        }
//                        
//                        ProfileMenuItem(icon: "doc.text.fill", text: "Privacy & Policy") {
//                            print("Privacy & Policy tapped")
//                        }
//                    }
//                    .padding(.horizontal, 20)
//                } else {
//                    ProgressView("Loading user data...")
//                        .task {
//                            await viewModel.loadCurrentUser()
//                        }
//                }
//                
//                Spacer()
//
//                // Logout Button
//                Button {
//                    Task {
//                        do {
//                            try AuthenticationManager.shared.signOut()
//                            navigateToSignIn = true // Set state to navigate
//                        } catch {
//                            print("Error during sign-out: \(error)")
//                        }
//                    }
//                }
//                label: {
//                    Text("Log out")
//                        .font(.headline)
//                        .foregroundColor(.white)
//                        .frame(height: 55)
//                        .frame(maxWidth: .infinity)
//                        .background(Color.red)
//                        .cornerRadius(10)
//                        .shadow(radius: 5)
//                }
//                .padding(.horizontal, 20)
//            }
//            .navigationBarBackButtonHidden(true)
//            .toolbar {
//                ToolbarItem(placement: .navigationBarLeading) {
//                    Button(action: {
//                        presentationMode.wrappedValue.dismiss()
//                    }) {
//                        Image(systemName: "chevron.left")
//                            .font(.headline)
//                            .foregroundColor(.yellow)
//                    }
//                }
//            }
//            .navigationDestination(isPresented: $navigateToSignIn) {
//                UserAuthenticationView(showSignInView: $navigateToSignIn) // Navigate to sign-in view
//            }
//        }
//    }
//}





//struct UserProfileView: View {
//    @StateObject private var viewModel = UserProfileViewModel()
//    @Environment(\.presentationMode) var presentationMode
//    @State private var navigateToSignIn = false // State to trigger navigation
//
//    var body: some View {
//        NavigationStack {
//            VStack (spacing: 20){
//                if let user = viewModel.user {
//                    // User Profile Image
//                    AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
//                        image.resizable()
//                            .frame(width: 100, height: 100)
//                            .clipShape(Circle())
//                            .padding(.top)
//                    } placeholder: {
//                        Image(systemName: "person.crop.circle")
//                            .resizable()
//                            .frame(width: 100, height: 100)
//                            .foregroundColor(.gray)
//                            .padding(.top)
//                    }
//
//                    // Display user's name or email if name is missing
//                    Text(user.firstName ?? user.email ?? "Anonymous User")
//                        .font(.title2)
//                        .fontWeight(.semibold)
//                        .padding(.top, 4)
//
//                    Divider()
//                        .padding(.vertical)
//
//                    // Menu Items
//                    List {
//
//                        Button("My Rentals") {
//                            print("My Rentals tapped")
//                        }
//
//                        NavigationLink(destination: UserSettingsView(showSignInView: $navigateToSignIn)) {
//                            Text("Settings")
//                        }
//
//                        Button("Contact us") {
//                            print("Support tapped")
//                        }
//                        
//                        Button("Privacy & Policy") {
//                            print("Privacy & Policy tapped")
//                        }
//                    }
//                    .listStyle(InsetGroupedListStyle())
//                } else {
//                    ProgressView("Loading user data...")
//                        .task {
//                            await viewModel.loadCurrentUser()
//                        }
//                }
//                Spacer()
//                Button {
//                    Task {
//                        do {
//                            try AuthenticationManager.shared.signOut()
//                            navigateToSignIn = true // Set state to navigate
//                        } catch {
//                            print("Error during sign-out: \(error)")
//                        }
//                    }
//                }
//                label: {
//                    Text("Log out")
//                        .font(.headline)
//                        .foregroundColor(.white)
//                        .frame(height: 55)
//                        .frame(maxWidth: .infinity)
//                        .background(Color.orange)
//                        .cornerRadius(10)
//                }
//                .padding()
//            }
//            //.navigationTitle("User Profile")
//            .navigationBarBackButtonHidden(true)
//            .toolbar {
//                ToolbarItem(placement: .navigationBarLeading) {
//                    Button(action: {
//                        presentationMode.wrappedValue.dismiss()
//                    }) {
//                        Image(systemName: "chevron.left")
//                            .font(.headline)
//                            .foregroundColor(.blue)
//                    }
//                }
//            }
//            .navigationDestination(isPresented: $navigateToSignIn) {
//                UserAuthenticationView(showSignInView: $navigateToSignIn) // Navigate to sign-in view
//            }
//        }
//    }
//}








// Content from: ../Equipment Booking/Core/Profile/UserProfileViewModel.swift

//
//  UserProfileViewModel.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 2/9/25.
//

import Foundation
import FirebaseAuth
import FirebaseFirestore

@MainActor
final class UserProfileViewModel: ObservableObject {
    @Published private(set) var user: DBUser? = nil
    @Published var authUser: AuthDataResultModel? = nil
        
    
    func loadCurrentUser() async {
        do {
            let authDataResult = try AuthenticationManager.shared.getAuthenticatedUser()
            self.authUser = authDataResult
            self.user = try await UserManager.shared.getUser(userID: authDataResult.uid)

            // Handle missing first name and last name
            if user?.firstName == nil || user?.lastName == nil {
                if let googleProfile = Auth.auth().currentUser?.providerData.first(where: { $0.providerID == "google.com" }) {
                    // Try to get names and photo from Google profile
                    let firstName = googleProfile.displayName?.components(separatedBy: " ").first
                    let lastName = googleProfile.displayName?.components(separatedBy: " ").dropFirst().joined(separator: " ")
                    let photoUrl = googleProfile.photoURL?.absoluteString
                    
                    // Update user instance
                    self.user = DBUser(
                        userId: authDataResult.uid,
                        email: authDataResult.email,
                        photoUrl: photoUrl ?? authDataResult.photoUrl,
                        firstName: firstName ?? authDataResult.email,
                        lastName: lastName
                        
                    )
                } else {
                    // Default to email if name is missing
                    self.user = DBUser(
                        userId: authDataResult.uid,
                        email: authDataResult.email,
                        photoUrl: authDataResult.photoUrl,
                        firstName: authDataResult.email,
                        lastName: nil
                        
                    )
                }
            }
        } catch {
            print("Failed to load user: \(error.localizedDescription)")
            self.user = DBUser(
                userId: "unknown",
                email: "Unknown User",
                firstName: "Anonymous",
                lastName: "User"
            )
        }
    }
    
    func updateUserProfile(firstName: String, lastName: String, phone: String, address: String, companyName: String, profession: String) async throws {
            guard let userId = user?.userId else { return }

            let db = Firestore.firestore()
            let userRef = db.collection("users").document(userId)

            let updatedData: [String: Any] = [
                "firstname": firstName,
                "lastname": lastName,
                "phone": phone,
                "address": address,
                "company_name": companyName,
                "profession": profession
            ]

            try await userRef.updateData(updatedData)
            print("User profile updated successfully.")
        }
    
}


// Content from: ../Equipment Booking/Core/Settings/ProfileSettingsView.swift

//
//  ProfileSettingsView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/13/25.
//

import SwiftUI

struct ProfileSettingsView: View {
    @State private var email: String = ""
    @State private var name: String = ""
    @State private var password: String = ""

    var body: some View {
        Form {
            Section(header: Text("Personal Information")) {
                TextField("Name", text: $name)
                    .autocapitalization(.words)
                TextField("Email", text: $email)
                    .keyboardType(.emailAddress)
            }

            Section(header: Text("Password")) {
                SecureField("New Password", text: $password)
            }

            Button(action: {
                // Save updated user information
            }) {
                Text("Save Changes")
                    .frame(maxWidth: .infinity, alignment: .center)
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.blue)
                    .cornerRadius(8)
            }
        }
        .navigationTitle("Profile Settings")
    }
}

#Preview {
    ProfileSettingsView()
}


// Content from: ../Equipment Booking/Core/Settings/SettingsViewModel.swift

//
//  SettingsViewModel.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/29/24.
//

import Foundation
import FirebaseAuth

@MainActor

final class UserSettingsViewModel: ObservableObject {
    @Published private(set) var user: DBUser? = nil
    @Published var authUser: AuthDataResultModel? = nil

    func loadCurrentUser() async {
        do {
            let authDataResult = try AuthenticationManager.shared.getAuthenticatedUser()
            self.authUser = authDataResult
            self.user = try await UserManager.shared.getUser(userID: authDataResult.uid)

            // Handle missing first name and last name
            if user?.firstName == nil || user?.lastName == nil {
                if let googleProfile = Auth.auth().currentUser?.providerData.first(where: { $0.providerID == "google.com" }) {
                    // Try to get names and photo from Google profile
                    let firstName = googleProfile.displayName?.components(separatedBy: " ").first
                    let lastName = googleProfile.displayName?.components(separatedBy: " ").dropFirst().joined(separator: " ")
                    let photoUrl = googleProfile.photoURL?.absoluteString

                    // Update user instance
                    self.user = DBUser(
                        userId: authDataResult.uid,
                        email: authDataResult.email,
                        photoUrl: photoUrl ?? authDataResult.photoUrl,
                        firstName: firstName ?? authDataResult.email,
                        lastName: lastName
                    )
                } else {
                    // Default to email if name is missing
                    self.user = DBUser(
                        userId: authDataResult.uid,
                        email: authDataResult.email,
                        photoUrl: authDataResult.photoUrl,
                        firstName: authDataResult.email,
                        lastName: nil
                    )
                }
            }
        } catch {
            print("Failed to load user: \(error.localizedDescription)")
            self.user = DBUser(
                userId: "unknown",
                email: "Unknown User",
                firstName: "Anonymous",
                lastName: "User"
            )
        }
    }
}

//final class UserSettingsViewModel: ObservableObject {
//    
//    @Published var authProviders: [AuthProvideroption] = []
//    @Published var authUser: AuthDataResultModel? = nil
//    
//    func loadAuthProviders() {
//        if let providers = try? AuthenticationManager.shared.getProviders() {
//            authProviders = providers
//        }
//        
//    }
//    
//    // Function to load authenticated user
//    
//    func loadauthUser() {
//        self.authUser = try? AuthenticationManager.shared.getAuthenticatedUser()
//    }
//    
//    
//    func signOut() throws {
//        try AuthenticationManager.shared.signOut()
//    }
//    
//    func resetPassword () async throws {
//        let authUser =  try AuthenticationManager.shared.getAuthenticatedUser()
//        
//        guard let email = authUser.email else {
//            
//            throw URLError(.fileDoesNotExist)
//        }
//        try await AuthenticationManager.shared.resetPassword(email: email)
//        
//    }
//    
//    
//    func updateEmail () async throws {
//        let email = "test123@gmail.com"
//        try await AuthenticationManager.shared.updateEmail(email: email)
//        
//    }
//    
//    func updatePassword () async throws {
//        let password = "test123"
//        try await AuthenticationManager.shared.updatePassword(password: password)
//        
//    }
//    
//    func linkGoogleAccount() async throws {
//        let helper = SignInGoogleHelper()
//        let tokens = try await helper.signIn()
//        self.authUser = try await AuthenticationManager.shared.linkGoogle(tokens: tokens)
//        
//    }
//    
//    /*
//    func linkAppleAccount() async throws {
//        let helper = SignInAppleHelper()
//        let tokens = try await helper.signInWithAppleFlow()
//        self.authUser = try await AuthenticationManager.shared.linkApple(tokens: tokens)
//    }
//     */
//    
//    func linkEmailAccount() async throws {
//        let email = "test2@testing.com"
//        let password = "1234321"
//        self.authUser = try await AuthenticationManager.shared.linkEmail(email: email, password: password)
//        
//    }
//    
//}


// Content from: ../Equipment Booking/Core/Settings/UserSettingsView.swift

//
//  UserSettingsView.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/9/24.
//
// UserSettingsView
import SwiftUI
import FirebaseAuth

struct UserSettingsView: View {
    @StateObject private var viewModel = UserSettingsViewModel()
    @Binding var showSignInView: Bool // Controls sign-out navigation
    @Environment(\.presentationMode) var presentationMode // For back navigation

    var body: some View {
        NavigationStack {
            VStack {
                if let user = viewModel.user {
                    // Profile Image & Name
                    VStack(spacing: 10) {
                        AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
                            image.resizable()
                                .frame(width: 100, height: 100)
                                .clipShape(Circle())
                        } placeholder: {
                            Image(systemName: "person.crop.circle.fill")
                                .resizable()
                                .frame(width: 100, height: 100)
                                .foregroundColor(.yellow)
                        }
                        .padding(.top)

                        Text(user.firstName ?? "User")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                    }

                    Divider()
                        .padding(.vertical)

                    // Settings Options
                    VStack(spacing: 15) {
                        SettingsMenuItem(icon: "key.fill", text: "Reset Password") {
                            resetPassword(for: user.email)
                        }
                        
                        NavigationLink(destination: UserProfileEditView()) {
                            SettingsMenuItem(icon: "pencil", text: "Update Profile")
                        }

                        SettingsMenuItem(icon: "arrow.backward.square", text: "Sign Out", color: .red) {
                            Task {
                                do {
                                    try AuthenticationManager.shared.signOut()
                                    showSignInView = true // Navigate back to login
                                } catch {
                                    print("Sign-out failed: \(error.localizedDescription)")
                                }
                            }
                        }
                    }
                    .padding(.horizontal, 20)
                } else {
                    ProgressView("Loading user settings...")
                        .task {
                            await viewModel.loadCurrentUser()
                        }
                }
            }
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        Image(systemName: "chevron.left")
                            .font(.headline)
                            .foregroundColor(.yellow)
                    }
                }
            }
        }
    }

    private func resetPassword(for email: String?) {
        guard let email = email else {
            print("Email not available for password reset")
            return
        }
        Task {
            do {
                try await AuthenticationManager.shared.resetPassword(email: email)
                print("Password reset email sent to \(email)")
            } catch {
                print("Failed to send reset email: \(error.localizedDescription)")
            }
        }
    }
}

// âœ… Reusable Settings Item (Same Look as Profile)
struct SettingsMenuItem: View {
    let icon: String
    let text: String
    var color: Color = .black
    var action: (() -> Void)? = nil

    var body: some View {
        Button(action: { action?() }) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(.yellow)
                    .font(.headline)
                Text(text)
                    .font(.headline)
                    .foregroundColor(color)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
            .padding()
            .background(RoundedRectangle(cornerRadius: 12).fill(Color.yellow.opacity(0.2)))
            .shadow(radius: 2)
        }
    }
}

#Preview {
    UserSettingsView(showSignInView: .constant(true))
}


//import SwiftUI
//import FirebaseAuth
//
//struct UserSettingsView: View {
//    @StateObject private var viewModel = UserSettingsViewModel()
//    @Binding var showSignInView: Bool // To handle sign-out and navigation back
//    
//
//    var body: some View {
//        NavigationStack {
//            VStack {
//                if let user = viewModel.user {
//                    // Profile Image and Welcome Message
//                    VStack(spacing: 10) {
//                        // Profile Image
//                        AsyncImage(url: URL(string: user.photoUrl ?? "")) { image in
//                            image.resizable()
//                                .frame(width: 100, height: 100)
//                                .clipShape(Circle())
//                        } placeholder: {
//                            Image(systemName: "person.crop.circle")
//                                .resizable()
//                                .frame(width: 100, height: 100)
//                                .foregroundColor(.gray)
//                        }
//                        .padding(.top)
//
//                        // Welcome Text
//                        Text(" \(user.firstName ?? "User")")
//                            .font(.title2)
//                            .fontWeight(.semibold)
//                            .padding(.bottom, 20)
//                    }
//
//                    // Settings Buttons
//                    List {
//                        Section {
//                            Button("Reset Password") {
//                                resetPassword(for: user.email)
//                            }
//                            NavigationLink(destination: UserProfileEditView()) {
//                                Text("Update Profile")
//                            }
//                            
//                        }
//
//                        // Sign Out Button
//                        Section {
//                            Button {
//                                Task {
//                                    do {
//                                        try AuthenticationManager.shared.signOut()
//                                        showSignInView = true // Navigate back to sign-in
//                                    } catch {
//                                        print("Sign-out failed: \(error.localizedDescription)")
//                                    }
//                                }
//                            } label: {
//                                Text("Sign Out")
//                                    .font(.headline)
//                                    .foregroundColor(.white)
//                                    .frame(height: 55)
//                                    .frame(maxWidth: .infinity)
//                                    .background(Color.orange)
//                                    .cornerRadius(10)
//                            }
//                        }
//                    }
//                    .listStyle(InsetGroupedListStyle())
//                } else {
//                    // Loading State
//                    ProgressView("Loading user settings...")
//                        .task {
//                            await viewModel.loadCurrentUser()
//                        }
//                }
//            }
//            .navigationTitle("User Settings")
//            .toolbar {
//                ToolbarItem(placement: .navigationBarLeading) {
//                    Button(action: {
//                        showSignInView = false // Navigate back to main view
//                    }) {
//                        Image(systemName: "chevron.left")
//                            .font(.headline)
//                            .foregroundColor(.blue)
//                    }
//                }
//            }
//        }
//    }
//
//    private func resetPassword(for email: String?) {
//        guard let email = email else {
//            print("Email not available for password reset")
//            return
//        }
//        Task {
//            do {
//                try await AuthenticationManager.shared.resetPassword(email: email)
//                print("Password reset email sent to \(email)")
//            } catch {
//                print("Failed to send reset email: \(error.localizedDescription)")
//            }
//        }
//    }
//}
//
//#Preview {
//    UserSettingsView(showSignInView: .constant(true))
//}





// Content from: ../Equipment Booking/Utilities/CustomTextFields.swift

//
//  CustomTextFields.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 2/9/25.
//

import SwiftUI

// Custom TextField
struct CustomTextField: View {
    var icon: String
    var placeholder: String
    @Binding var text: String

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.yellow)
            TextField(placeholder, text: $text)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)
        }
        .padding()
        .overlay(RoundedRectangle(cornerRadius: 10).stroke(Color.yellow, lineWidth: 2))
        .background(Color.clear)
        .foregroundColor(Color(UIColor.darkGray))
    }
}

// Custom SecureField with Toggle
struct CustomSecureField: View {
    var icon: String
    var placeholder: String
    @Binding var text: String
    var isSecure: Bool
    var toggle: () -> Void

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.yellow)
            if isSecure {
                SecureField(placeholder, text: $text)
            } else {
                TextField(placeholder, text: $text)
            }
            Button(action: toggle) {
                Image(systemName: isSecure ? "eye.slash" : "eye")
                    .foregroundColor(.gray)
            }
        }
        .padding()
        .overlay(RoundedRectangle(cornerRadius: 10).stroke(Color.yellow, lineWidth: 2))
        .background(Color.clear)
        .foregroundColor(Color(UIColor.darkGray))
    }
}


// Content from: ../Equipment Booking/Utilities/EquipmentsDatabase.swift

//
//  EquipmentsDatabase.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 1/6/25.
//

import Foundation

struct EquipmentArray: Codable {
    let equipments: [Equipment]
    let total, skip, limit: Int
}

struct Equipment: Identifiable, Codable {
    var equip_id: String // unique id
    var id: String {equip_id} // conform to Identifiable by mapping 'id' to 'equip_id'
    var availability_status: String?
    var description: String?
    var equipment_main_category: String?
    var equipment_sub_category: String?
    var equipment_name: String?
    var img_name: String?
    var img_url: String?
    var manufacturer: String?
    var rental_price_per_day: Double?
    
}

final class EquipmentsDatabase {
    
    static let equipments: [Equipment] = [
        Equipment(equip_id: "CC-C-2", availability_status: "available", description: "The Liebherr 32 TTR is the crane for you who value maximum flexibility and mobility. This crawler construction crane with self-elevating properties expands your possibilities to get ahead on the jobsite.", equipment_main_category: "Construction Cranes", equipment_sub_category: "Crawler", equipment_name: "Liebherr 32 TTR", img_name: "712322-31.Jpg", img_url: "https://storage.googleapis.com/equipment-management-db.firebasestorage.app/Equipment_imgs/712322-31.Jpg", manufacturer: "Liebherr", rental_price_per_day: 100),
        
    ]
}


// Content from: ../Equipment Booking/Utilities/InputValidator.swift

//
//  InputValidator.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 2/9/25.
//

import Foundation

struct ValidationHelper {
    
   // Validates email and returns an error message (or nil if valid)
    static func validateEmail(_ email: String) -> String? {
        let emailRegex = "^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"
        return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: email) ? nil : "Please enter a valid email address."
    }

    //Validates if passwords match and returns an error message (or nil if valid)
    static func validateConfirmPassword(password: String, confirmPassword: String) -> String? {
        return password == confirmPassword ? nil : "Passwords do not match."
    }
}



// Content from: ../Equipment Booking/Utilities/Utilities.swift

//
//  Utilities.swift
//  Equipment Booking
//
//  Created by XXXXXXXX on 12/28/24.
//

import Foundation
import UIKit


// Get top view controller for use in google sign in

final class Utilities {
    static let shared = Utilities()
    private init() {}
    
    @MainActor
    // Struct to add a clear button to textfields

  
    func topViewController(controller: UIViewController? = nil) -> UIViewController? {
        
        let controller = controller ?? UIApplication.shared.keyWindow?.rootViewController
        
        if let navigationController = controller as? UINavigationController {
            return topViewController(controller: navigationController.visibleViewController)
        }
        if let tabController = controller as? UITabBarController {
            if let selected = tabController.selectedViewController {
                return topViewController(controller: selected)
            }
        }
        if let presented = controller?.presentedViewController {
            return topViewController(controller: presented)
        }
        return controller
    }
    
}



